<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>最大公约数与最小公倍数</title>
    <link href="/2025/10/28/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
    <url>/2025/10/28/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1>欧几里得算法（计算最大公倍数）</h1><p>设<br>$$ a = bq + r $$<br>同时 $a$ 和 $b$ 有共同约数 $t$<br>$$ a = ut $$<br>$$ b = vt $$<br>则<br>$$<br>a \mod b = (u - vq)t<br>$$<br>显然 $a \mod b$ 也有约数 $t$<br>可知 $a$ 和 $b$ 与 $a \mod b$ 有相等的最大公约数.<br>由此证明了<br>$$<br>\gcd(a, b) = \gcd(b, a \mod b)<br>$$<br>同时，我们有<br>$$<br>\gcd(a, 0) = a<br>$$<br>我们只需不断计算使 $a \mod b = 0$ 即可.<br>由此给出该算法的 C++ 实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> m,<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> t = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (t != <span class="hljs-number">0</span>) &#123;<br>        t = m % n;<br>        m = n;<br>        n = t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m;<br>&#125;<br></code></pre></td></tr></table></figure><h1>计算最小公倍数</h1><p>我们不加证明地给出<br>$$<br>lcm(a, b) = \frac{\left| a \times b \right|}{\gcd(a, b)}<br>$$<br>所以仅需计算 $ a \times b $ 和 $ \gcd(a, b) $ 即可.<br>实际应用中可能需要交换乘法和除法的顺序以避免溢出.</p><p>对于多个数的情况，有<br>$$<br>lcm(a1​,a2​,a3​,…,an​)=lcm(lcm(a1​,a2​),a3​,…)<br>$$<br>C++实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> m,<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> t = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (t != <span class="hljs-number">0</span>) &#123;<br>        t = m % n;<br>        m = n;<br>        n = t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> N;<br>    cin &gt;&gt; N;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a;<br>    cin &gt;&gt; a;  <span class="hljs-comment">// first number</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> lcm = a;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) &#123;<br>        cin &gt;&gt; a;<br>        lcm = (lcm / <span class="hljs-built_in">gcd</span>(lcm, a)) * a; <span class="hljs-comment">//avoid overflow</span><br>    &#125;<br>    cout &lt;&lt; lcm &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Programming from the Ground Up notes</title>
    <link href="/2025/08/18/Assembly-notes/"/>
    <url>/2025/08/18/Assembly-notes/</url>
    
    <content type="html"><![CDATA[<p>本文是 Jonathan Bartlett 撰写的 <em>Programming from the Ground Up</em> 书的笔记</p><h1>Chapter 1 介绍</h1><h2 id="工具">工具</h2><p>本书讨论的是x86的汇编语言和 GNU/Linux 操作系统，所以我们会使用标准的 GCC 工具集。<br>Tips：本书使用<strong>AT&amp;T</strong>语体</p><h1>Chapter 2 计算机架构</h1><p>现代计算机架构基于冯诺依曼架构，包括两个部分——<strong>CPU</strong>和<strong>内存</strong>。</p><h2 id="计算机内存的结构">计算机内存的结构</h2><p>存储在计算机的内存里面的不止是数据，还有控制计算机操作的程序。除了它们被使用的方式不同，它们都以相同的方式储存在内存中并以相同的方式访问。</p><h2 id="中央处理器（CPU）">中央处理器（CPU）</h2><p>CPU从内存中读取指令并执行它们。这被称为 <code>fetch-excute cycle</code><br>为了实现这个，CPU包含：</p><ul><li>程序计数器（Program Counter）</li><li>指令解码器（Instruction Decoder）</li><li>数据总线（Data bus）</li><li>通用寄存器（General-purpose registers）</li><li>算术和逻辑单元（Arithmetic and logic unit）</li></ul><p>程序计数器告诉计算机该从哪里获取下一条指令。程序计数器保存着下一个该被执行的指令的内存地址。CPU通过程序计数器中储存的内存地址，将对应地址的指令传递给指令解码器。指令解码器将解码指令并指明该条指令有关的内存地址。计算机指令一般由实际的指令和一些内存地址组成。<br>然后计算机用数据总线来获取待处理的内存位置。数据总线用来连接CPU和内存的物理连线，就像主板上的线那样。<br>除了处理器外面的内存，处理器自己还有一些特殊的高速的内存位置，称作<strong>寄存器（registers）</strong>。有两种寄存器——<strong>通用寄存器（General-purpose registers）</strong> 和 <strong>专用寄存器（Special-purpose registers）</strong>。<br>现在CPU已经获取到了它需要的所有数据，它将数据和已解码的指令传递给算术和逻辑单元来进行进一步处理。指令实际上就是在这里被执行的。在计算完成之后，结果被放在数据总线上并被储存到合适的内存位置或寄存器中。<br>这是一个极度简化了的过程，事实上，现代计算机已经进步了很多， 以上的过程并未考虑缓存层次结构、超标量处理器、流水线、分支预测、乱序执行、微码转换、协处理器和其他优化。</p><h2 id="一些术语">一些术语</h2><p>计算机的内存是固定大小的有序的存储空间。每个存储位置对应的编号叫做它的 <strong>地址（address）</strong> 单个存储位置的大小叫做 <strong>字节（byte）</strong> 。在x86处理器上，一字节就是一个0到255的数。<br>计算机可以使用ASCII来处理文字。<br>如果我们需要表示比255大的数字怎么办？我们可以吧多个字节整合在一起，比如两个字节最大表示65535，四个字节最大可以表示4294967295。幸运的是，我们不必手动把字节捏在一起，事实上，计算机会帮我们处理细节。<strong>我们默认处理四字节长的数据</strong><br>你可以把寄存器想象为你的桌子，上面保存着你要处理的数据。<br>在计算机上，一个典型的寄存器的大小叫做一个电脑的<strong>字长（word size）</strong>。x86处理器的字长为四字节。这意味着四字节是在x86上处理的最自然的。地址也是四字节长的，所以它能塞进一个寄存器内，<br>储存在内存中的地址也叫做<strong>指针（pointers）</strong>。它们指向一个不同的内存位置。<br>正如我们前面提到的，计算机指令和数据以一致的方式储存着。区别他俩的唯一方式就是通过一个专用寄存器叫做指令指针，它指向内存中的指令。如果指令指针指向一个内存字，那么它就会被解释为指令。</p><h2 id="解读内存">解读内存</h2><p>计算机十分精确，所以你对你在操作什么东西必须十分明白。</p><h2 id="数据访问方法">数据访问方法</h2><p>处理器有很多访问数据的方法，称作<strong>寻址模式（addressing modes）</strong>  。<br>最简单的寻址模式是<strong>立即模式（immediate mode）</strong>，数据直接内嵌在处理器中，比如我们要载入数字0，那么就可以指定立即模式直接写入0。<br><strong>寄存器寻址模式（register addressing mode）</strong>，指令包含一个要访问的寄存器，而不是一个内存地址。剩余的模式会处理内存地址。<br><strong>直接寻址模式（direct addressing mode）</strong>  ，指令包含着要访问的内存地址。计算机会直接从指定的内存地址获取数据。<br><strong>索引寻址模式（indexed addressing mode）</strong>，指令包含内存地址，并且还指定了一个 <strong>索引寄存器（index register）</strong> 来对那个地址进行 <strong>偏移（offset）</strong> 。比方说你指定了地址114510，偏移寄存器储存为4，那么你实际访问的地址就是114514。在x86处理器上，你还可以给索引寄存器指定一个 <strong>倍数（multiplier）</strong> 以便一次访问若干个字节的内存。<br><strong>间接寻址模式（indirect addressing mode）</strong> ，指令包含一个寄存器，里面储存着一个指针指向我们要访问的地方。比如<code>%eax</code>寄存器中储存着值4，那么在间接寻址模式下，我们就去内存地址为4的位置加载数据，而在直接寻址模式，我们直接载入4。<br>最后，是 <strong>基指针寻址模式（base pointer addressing mode）</strong> 。和间接寻址模式相似，但是你还要加入偏移来向寄存器加上偏移值再访问数据。<br>还有其他的寻址模式，在这里我们只介绍重要的几个。</p><h1>Chapter 3 你的第一个程序</h1><h2 id="输入一个程序">输入一个程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#exit.s: 一个简单的程序，退出并向内核返回一个状态码。<br>.section .data<br>.section .text #这一部分是指令<br>.global _start #表明_start符号（symbol）<br>                #符号通常用来标记程序或数据的位置，你可以用符号的名字而不是地址来引用它<br>                # .global表明汇编器不应该丢弃这个符号，因为链接器会需要<br>                #_start 应永远与.global 使用，否则电脑不知道从哪里开始执行你的程序<br>_start: #定义了_start标签（lable）的值<br>        #标签就是一个符号后面跟一个冒号<br>        #标签定义了符号的值<br>movl $1, %eax #系统调用编号，将数字1传入%eax寄存器<br>              #数字1前加$符号表示我们使用立即模式<br>movl $0, %ebx #返回的状态码，将数字0传入%ebx寄存器<br>int $0x80 #内核中断，int代表中断（interrupt）<br></code></pre></td></tr></table></figure><p>使用 <code>as exit.s -o exit.o</code> 和 <code>ld exit.o -o exit</code> 来汇编并链接。</p><h2 id="汇编语言小知识">汇编语言小知识</h2><p>中断就是中断正常的指令流，把控制权交给内核来完成 <strong>系统调用（system call）</strong> ，系统调用完成后再将控制权交回程序。<br><strong>系统调用快速回顾：</strong> 简而言之，系统的功能可以通过系统调用来访问。通过特别地设置寄存器并执行<code>int 0x80</code>指令，Linux 内核通过 <code>%eax</code> 寄存器的值知道我们要访问哪个系统调用，在上面的例子中，系统调用序号1就是<code>exit</code>调用，需要把状态码放在 <code>%ebx</code> 寄存器中。</p><p>在x86处理器上，有几个通用寄存器（都可以使用 <code>movl</code> 指令），包括：</p><ul><li><code>%eax</code></li><li><code>%ebx</code></li><li><code>%ecx</code></li><li><code>%edx</code></li><li><code>%edi</code></li><li><code>%esi</code></li></ul><p>还有专用寄存器，包括：</p><ul><li><code>%ebp</code></li><li><code>%esp</code></li><li><code>%eip</code></li><li><code>%eflags</code></li></ul><p>像 <code>%eip</code> 和 <code>%eflags</code> 这种只能通过特殊的指令访问。其他的寄存器可以像通用寄存器那样用普通的指令访问，但是他们有特殊的意义和用途。</p><h2 id="找到最大值">找到最大值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># maximum.s: 找出一组数据的最大值<br># %edi储存着正在处理的数据的索引<br># %ebx储存着目前找到的最大的数据<br># %eax储存着目前的数据<br>.section .data<br><br>data_items: # 没有_global标志，我们只在程序内部使用它<br> .long 3,67,34,222,45,75,54,34,44,33,22,11,66,0<br><br>.section .text<br><br>.global _start<br><br>_start:<br> movl $0, %edi<br> movl data_items(,%edi,4),  %eax<br> movl %eax, %ebx<br><br>start_loop:<br> cmpl $0, %eax<br> je loop_exit<br> incl %edi<br> movl data_items(,%edi,4), %eax<br> cmpl %ebx, %eax<br> jle start_loop<br> movl %eax, %ebx<br> jmp start_loop<br><br>loop_exit:<br> movl $1, %eax<br> int 0x80<br></code></pre></td></tr></table></figure><p>通过 <code>echo $?</code> 来获得运行结果<br>第八行的 <code>.long</code> 表示保留的内存位置的类型，有：</p><ul><li><code>.byte</code>:占据一个存储位置，0-255</li><li><code>.int</code>：占据两个存储位置，0-65535</li><li><code>.long</code>：占据四个存储位置，0-4294967295</li><li><code>.ascii</code>：在内存中储存字符串，如 <code>.ascii &quot;Hello there\0&quot;</code> 就会以ascii码的形式在内存中储存12个字节，其中 <code>\0</code> 表示字符串的终止，不会显示在屏幕上。</li></ul><p>第十六行的 <code>movl data_items(,%edi,4)</code> 表示从data_items开始，以 <code>%edi</code> 为索引，一次获取四个字节的数据并将其储存在 <code>%eax</code> 寄存器中。索引寻址模式更一般的形式是：<br><code>movl 开始的地址(,%索引寄存器,字长)</code><br>下一个 <code>cmpl</code> 指令是比较两个值，影响到 <code>%eflags</code> 寄存器，也称作状态寄存器。紧接着的是流控制指令 <code>je</code> ，它使用状态寄存器来获取上一次比较的结果，还有很多跳转指令：</p><ul><li><code>je</code> 如果相等就跳转</li><li><code>jg</code> 如果第二个比较的值比第一个大就跳转</li><li><code>jge</code> 如果第二个比较的值大于等于第一个就跳转</li><li><code>jl</code> 如果第二个比较的值小于第一个就跳转</li><li><code>jle</code> 如果第二个比较的值小于等于第一个就跳</li><li><code>jmp</code> 无论情况如何，直接跳转</li></ul><p><code>incl %edi</code> 表示将 <code>%edi</code> 加1</p><h2 id="寻址模式">寻址模式</h2><p>通用的内存地址引用是：<br><code>地址或偏移(%基准或偏移,%索引,倍数)</code><br><code>最终地址 = 地址或偏移 + %基准或偏移 + 倍数 * %索引</code></p><h3 id="直接寻址模式">直接寻址模式</h3><p>只使用地址或偏移部分，例如 <code>movl ADDRESS, %eax</code> 将在ADDRESS内存地址的值载入 <code>%eax</code> 寄存器</p><h3 id="索引寻址模式">索引寻址模式</h3><p>例如 <code>movl string_start(,%ecx,1), %eax</code> 从 <code>string_start</code> 开始，再加上 <code>1*%ecx</code> ，将最终的值载入<code>%eax</code></p><h3 id="间接寻址模式">间接寻址模式</h3><p>间接寻址模式将一个寄存器中保存的内存地址对应的值载入，例如 <code>movl (%eax), %ebx</code> 将 <code>%eax</code> 储存的内存地址的值载入<code>%ebx</code></p><h3 id="基指针寻址模式">基指针寻址模式</h3><p>基指针寻址与间接寻址模式相似，除了它向寄存器中储存的内存地址加上一个常量。例如<code>movl 4(%eax), %ebx</code></p><p>除此之外，我们还能操作不同大小的数据，例如<code>movb</code>可以一次移动一个字节的数据，而且我们可以使用部分寄存器。<br>拿 <code>%eax</code> 举个例子，如果你想一次使用两个字节，那么 <code>%ax</code> 就是 <code>%eax</code> 的后半部分， <code>%ax</code> 还能再分为两个一字节大小的寄存器，前半部分叫 <code>%ah</code> ，后半部分叫 <code>%al</code>。<br><img src="../../themes/fluid/source/img/half_reg_demo.png" alt="%eax寄存器的布局"><br>使用部分的寄存器会损坏之前的数据，请小心。</p><h1>Chapter 4 函数</h1><h2 id="函数是如何工作的">函数是如何工作的</h2><p>函数由以下几部分组成：</p><ul><li>函数名（function name）</li><li>函数参数（function parameters）</li><li>局部变量（local variables）</li><li>静态变量（static variables）</li><li>全局变量（global variables）</li><li>返回地址（return address）</li><li>返回值（return value）</li></ul><p>不同的语言的变量储存、参数传递和返回地址传递的方式不同。这种区别就是不同的 <strong>调用约定（calling convention）</strong>。<br>汇编语言允许你使用任何语言的调用约定，你甚至可以自己实现一个调用约定，但为了与其他语言兼容，最好采用对应的方式。<br>这里我们介绍C语言的调用约定。</p><h2 id="使用C调用约定的汇编语言函数">使用C调用约定的汇编语言函数</h2><h3 id="栈">栈</h3><p>我们先要了解栈（stack）是什么。你的电脑有栈，它在内存地址的顶部。你可以用 <code>pushl</code> 向栈的顶部压入东西，也可以用 <code>popl</code> 弹出东西。虽然我们说“栈的顶部”，但是栈在内存地址的顶部，所以栈是向下增长的，新数据在栈内存地址的下面。我们可以一直往栈里压入东西，栈顶部会移动来容纳我们的数据，直到栈往下增长碰到我们的代码或其他数据。<br>所以我们怎么知道栈的顶部在哪？<code>%esp</code> （栈寄存器）寄存器保存着指向栈顶部的指针。每次我们用 <code>pushl</code> 压入栈， <code>%esp</code> 就会减4来指向栈顶部，用 <code>popl</code> 弹出栈，它就会加4。<br>可以使用各种寻址模式来访问栈中各种位置的数据。</p><h3 id="C语言函数调用约定">C语言函数调用约定</h3><p>C语言首先将参数反向地压入栈中，然后执行 <code>call + 函数名</code> 指令调用函数， <code>call</code> 会将返回地址压入栈顶，并修改 <code>%eip</code> 寄存器（指令指针）使其指向函数开始的指令的地址。函数刚调用时栈看起来像这样：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elm">参数<span class="hljs-type">N</span>  <br>...  <br>参数<span class="hljs-number">2</span>  <br>参数<span class="hljs-number">1</span>  <br>返回地址 &lt;-<span class="hljs-comment">--- (%esp)</span><br></code></pre></td></tr></table></figure><p>调用函数后，第一件事就是将原来的基指针寄存器（ <code>%ebp</code> ）压住栈中保存，并将 <code>%ebp</code> 移动到 <code>%esp</code>的位置（ <code>movl %esp, %ebp</code> ），这样无论怎么压入弹出栈，你总能通过位于函数开始位置的 <code>%ebp</code> 轻松地访问栈中各个位置。<br>这样， <code>%esp</code> 就能自由移动，将其减去相应的字节数来创建更多的栈的空间供函数使用（比如储存局部变量）。<br>当函数干完活了，它按下面的流程滚蛋：<br>1.在 <code>%eax</code> 中储存返回值。<br>2.将栈指针恢复到调用前的样子。<br>3.使用 <code>ret</code> 指令，从栈顶获得返回地址并将 <code>%eip</code> 设定到那里。将控制权交回原程序。<br>执行下面的指令：</p> <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">movl <span class="hljs-variable">%ebp</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%esp</span><br>popl <span class="hljs-variable">%ebp</span><br><span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><p>所有的局部变量都已销毁，现在可以在 <code>%eax</code> 找到返回值，若不需要调用参数，还需要把 <code>%esp</code> 加4*参数数量（ <code>addl</code> ）。<br>注意：调用函数的时候除了 <code>%ebp</code> 会保留原来的内容，你应该假设其它寄存器都被清空了。<br>这是一个简化了的版本，具体细节可以在<a href="http://www.linuxbase.org/spec/refspecs/">这里</a>查询 <em>System V Application Binary Interface- Intel386 Architecture<br>Processor Supplement</em></p><h3 id="一个使用函数的例子">一个使用函数的例子</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs mel"># 演示计算<span class="hljs-number">2</span>^<span class="hljs-number">3</span>+<span class="hljs-number">5</span>^<span class="hljs-number">2</span><br>.section .data<br>.section .<span class="hljs-keyword">text</span><br>.<span class="hljs-keyword">global</span> _start<br><br>_start:<br> pushl $3<br> pushl $2<br> call power<br> addl $8, %esp<br><br> pushl %eax<br><br> pushl $2<br> pushl $5<br> call power<br> addl $8, %esp<br><br> popl %ebx<br> addl %eax, %ebx<br><br> movl $1, %eax<br> <span class="hljs-keyword">int</span> <span class="hljs-number">0x80</span><br><br>.type power, @function # 告知链接器 power 应被视为一个函数<br>power:<br> pushl %ebp<br> movl %esp, %ebp<br> subl $4, %esp<br> <br> movl <span class="hljs-number">8</span>(%ebp), %ebx<br> movl <span class="hljs-number">12</span>(%ebp), %ecx<br><br> movl %ebx, <span class="hljs-number">-4</span>(%ebp)<br><br>power_loop_start:<br> cmpl $1, %ecx<br> je end_power<br> movl <span class="hljs-number">-4</span>(%ebp), %eax<br> imull %ebx, %eax<br> movl %eax, <span class="hljs-number">-4</span>(%ebp)<br> decl %ecx<br> jmp power_loop_start<br><br>end_power:<br> movl <span class="hljs-number">-4</span>(%ebp), %eax<br> movl %ebp, %esp<br> popl %ebp<br> ret<br></code></pre></td></tr></table></figure><h3 id="递归函数">递归函数</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mel"># 此程序计算<span class="hljs-number">4</span>的阶乘<br>.section .data<br>.section .<span class="hljs-keyword">text</span><br>.<span class="hljs-keyword">global</span> _start<br>.<span class="hljs-keyword">global</span> factorial<br>_start:<br> pushl $4<br> call factorial<br> addl $4, %esp<br> movl %eax, %ebx<br> movl $1, %eax<br> <span class="hljs-keyword">int</span> <span class="hljs-number">0x80</span><br>factorial:<br> pushl %ebp<br> movl %esp, %ebp<br> movl <span class="hljs-number">8</span>(%ebp), %eax<br> cmpl $1, %eax<br> je end_factorial<br> decl %eax<br> pushl %eax<br> call factorial<br> movl <span class="hljs-number">8</span>(%ebp), %ebx<br> imull %ebx, %eax<br>end_factorial:<br> movl %ebp, %esp<br> popl %ebp<br> ret<br></code></pre></td></tr></table></figure><h1>Chapter Final(?)</h1><p>如你所见，这篇笔记到末尾了。这里面肯定还有错误，希望广大读者能指出，鄙人不才，献丑了。<br>汇编是一种看起来简单但使用起来极其复杂的底层语言，在高级语言流行的时代，我们不能粗暴的忽视汇编，相反，接触一些汇编知识会让我们对计算机架构和高级语言的指针有更深刻的理解，也为逆向和信息安全领域打下一些基础。<br><em>Programming from the Ground Up</em> 这本书还有内容，由于笔者精力和个人安排，笔记就记录到这，后面可能会更新一点第五章的内容。<br>E.O.F.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android 调试小课堂</title>
    <link href="/2024/08/25/Android-%E8%B0%83%E8%AF%95%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    <url>/2024/08/25/Android-%E8%B0%83%E8%AF%95%E5%B0%8F%E8%AF%BE%E5%A0%82/</url>
    
    <content type="html"><![CDATA[<p><em><strong>原文由 Nicholas Lim (niclimcy) 和 Nolen Johnson (npjohnson) 写于2023年10月10日，发表于<a href="https://lineageos.org/engineering/HowTo-Debugging/">LineageOS博客</a></strong></em></p><p><em>人工翻译，水平较差xD</em></p><p><img src="https://lineageos.org/images/engineering/hero_debugging.jpg" alt=""></p><h2 id="术语表">术语表</h2><ul><li>ADB： Android 调试桥。</li><li>缓冲区：内存中固定大小的存储区域。</li><li>CLI： 命令行界面。</li><li>Commits：对于代码库的原子更改，用于版本控制。</li><li>调试：找到并修复错误、bug和非预期行为的过程。</li><li>设备块文件：存在于/dev目录下的特殊文件，可与内核驱动进行标准化交互。</li><li>DTS： 设备树源码。</li><li>EDL：高通紧急下载模式。</li><li>gdb：GNU 调试器。</li><li>HAL：硬件抽象层。</li><li>内核空间：内核运行设备驱动并与之交互的地方。</li><li>记录日志：记录并存储运行软件时发生的事件，比如错误信息、警告和调试信息。</li><li>内存地址：内存中存储数据和指令的位置的独特的标识符。</li><li>OEM：原始设备制造商（例如谷歌、Fairphone、三星等）。</li><li>PID：进程ID。</li><li>pstore：持久性存储。</li><li>变基：将 commit 从一个分支移动到另一个分支的过程。</li><li>堆栈跟踪：导致程序出现错误或非预期行为的时候的函数调用序列。</li><li>TID：线程ID。</li><li>UART：通用异步收发器。</li><li>用户空间：正常进程（比如应用程序）运行的地方。</li></ul><h2 id="什么是调试？">什么是调试？</h2><p>了解 Android 调试，更重要的是了解 Android 系统中的各个部分。总体看，Android 系统主要由三个部分组成：应用程序、平台和内核。</p><p><img src="https://lineageos.org/images/engineering/content_android_stack.png" alt=""></p><h2 id="用户空间调试">用户空间调试</h2><h3 id="ADB">ADB</h3><p>Android 调试桥（ADB）允许我们访问设备的命令行界面（或者shell），让我们可以使用原生的调试工具比如 Logcat。欲知如何在你的设备上使用 ADB 和 fastboot，请访问我们的<a href="https://wiki.lineageos.org/adb_fastboot_guide">wiki</a></p><h3 id="logcat">logcat</h3><p><code>logcat</code> 是一个输出多种系统日志的命令行工具，可以输出包括你使用 Log 类从应用程序写入的消息。</p><p><code>logcat</code> 进程存储了各种循环缓冲区，可以使用<code> -b</code> 选项访问它们，有以下选项：</p><ul><li><p><code>radio</code>：查看包含了无线电/电话相关信息的缓冲区。</p></li><li><p><code>events</code>：查看已解释的二进制系统事件缓冲区信息。</p></li><li><p><code>main</code>：查看主日志缓冲区（默认），不包含 system 和 crash 日志信息。</p></li><li><p><code>system</code>：查看系统日志缓冲区（默认）。</p></li><li><p><code>crash</code>：查看崩溃日志缓冲区（默认）。</p></li><li><p><code>all</code>：查看所有缓冲区</p></li><li><p><code>default</code>：汇报main、system 和 crash 缓冲区。</p></li></ul><p>你可以在 <a href="https://developer.android.com/tools/logcat">Android Developers</a> 上找到更多关于如何使用 <code>logcat</code> 的信息。</p><p>这是用 <code>logcat</code> 获取 crash （崩溃）缓冲区的实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">adb logcat -b crash</span><br>+--------------------+-----+-----+-------+-----------------------------------------------------------------------+<br>| Date  Time         | PID | TID | Level | ProcessName   : Message                                               |<br>+--------------------+-----+-----+-------+-----------------------------------------------------------------------+<br>| 04-14 11:22:34.256 | 5199| 5199| E     | AndroidRuntime: FATAL EXCEPTION: main                                 |<br>| 04-14 11:22:34.256 | 5199| 5199| E     | AndroidRuntime: Process: com.android.settings, PID: 5199              |<br>| 04-14 11:22:34.256 | 5199| 5199| E     | AndroidRuntime: java.lang.RuntimeException: Unable to resume activity |<br>|                    |     |     |       |            &#123;com.android.settings/com.android.settings.SubSettings&#125;:   |<br>|                    |     |     |       |            java.lang.ArrayIndexOutOfBoundsException length=7; index=7 |<br>+--------------------+-----+-----+-------+-----------------------------------------------------------------------+<br></code></pre></td></tr></table></figure><p>崩溃缓冲区对于调试应用崩溃（比如<em>设置</em>应用停止运行）和识别运行时错误很有用。</p><h3 id="Tombstones">Tombstones</h3><p>有时候 ADB 服务可能没有在运行（可能原因包括在 adb 启动之前一个系统进程出现问题导致重启）。在这种情况下，我们不能够访问 logcat 命令。不要担心，一个墓碑文件已被写入 <code>/data/tombstones</code> ，其中包括引起崩溃的堆栈跟踪。</p><p>Tombstones 也更详细，如果 logcat 输出不足，则它会提供更长的堆栈跟踪。因此，也可以使用以下命令从正在运行的进程中导出 tombstone ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">adb shell debuggerd &#123;PID&#125;</span><br></code></pre></td></tr></table></figure><p>提示：将 {PID} 替换为实际的进程 ID。</p><h3 id="Stack">Stack</h3><p><code>stack</code> 是一个 Python 脚本，以人类可读的格式表示崩溃转储（符号化本机崩溃转储）。你可以在任何 LineageOS 存储库的本地同步的 ~/android/lineage/development/scripts/stack 的路径中找到 <code>stack</code>。可以使用 <code>stack &lt; /path/to/tombstone_0</code> 在提取的 tombstone 上运行 stack。</p><p>本机崩溃转储通常如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***<br>Build fingerprint: &#x27;Android/aosp_angler/angler:7.1.1/NYC/enh12211018:eng/test-keys&#x27;<br>Revision: &#x27;0&#x27;<br>ABI: &#x27;arm&#x27;<br>pid: 17946, tid: 17949, name: crasher  &gt;&gt;&gt; crasher &lt;&lt;&lt;<br>signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0xc<br>    r0 0000000c  r1 00000000  r2 00000000  r3 00000000<br>    r4 00000000  r5 0000000c  r6 eccdd920  r7 00000078<br>    r8 0000461a  r9 ffc78c19  sl ab209441  fp fffff924<br>    ip ed01b834  sp eccdd800  lr ecfa9a1f  pc ecfd693e  cpsr 600e0030<br><br>backtrace:<br>    #00 pc 0004793e  /system/lib/libc.so (pthread_mutex_lock+1)<br>    #01 pc 0001aa1b  /system/lib/libc.so (readdir+10)<br>    #02 pc 00001b91  /system/xbin/crasher (readdir_null+20)<br>    #03 pc 0000184b  /system/xbin/crasher (do_action+978)<br>    #04 pc 00001459  /system/xbin/crasher (thread_callback+24)<br>    #05 pc 00047317  /system/lib/libc.so (_ZL15__pthread_startPv+22)<br>    #06 pc 0001a7e5  /system/lib/libc.so (__start_thread+34)<br>Tombstone written to: /data/tombstones/tombstone_06<br></code></pre></td></tr></table></figure><p>运行 <code>stack &lt; /data/tombstones/tombstone_06</code> ，输出如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">Revision: &#x27;0&#x27;<br>pid: 17946, tid: 17949, name: crasher  &gt;&gt;&gt; crasher &lt;&lt;&lt;<br>signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0xc<br>     r0 0000000c  r1 00000000  r2 00000000  r3 00000000<br>     r4 00000000  r5 0000000c  r6 eccdd920  r7 00000078<br>     r8 0000461a  r9 ffc78c19  sl ab209441  fp fffff924<br>     ip ed01b834  sp eccdd800  lr ecfa9a1f  pc ecfd693e  cpsr 600e0030<br>Using arm toolchain from: ~/android/lineage/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/<br><br>Stack Trace:<br>  RELADDR   FUNCTION                   FILE:LINE<br>  0004793e  pthread_mutex_lock+2       bionic/libc/bionic/pthread_mutex.cpp:515<br><span class="hljs-meta prompt_">  v------&gt; </span><span class="language-bash"> ScopedPthreadMutexLocker   bionic/libc/private/ScopedPthreadMutexLocker.h:27</span><br>  0001aa1b  readdir+10                 bionic/libc/bionic/dirent.cpp:120<br>  00001b91  readdir_null+20            system/core/debuggerd/crasher.cpp:131<br>  0000184b  do_action+978              system/core/debuggerd/crasher.cpp:228<br>  00001459  thread_callback+24         system/core/debuggerd/crasher.cpp:90<br>  00047317  __pthread_start(void*)+22  bionic/libc/bionic/pthread_create.cpp:202 (discriminator 1)<br>  0001a7e5  __start_thread+34          bionic/libc/bionic/clone.cpp:46 (discriminator 1)<br></code></pre></td></tr></table></figure><p><code>stack</code> 的工作原理与内核空间调试工具<code>decode_stacktrace.sh</code> 非常相似。它们都提供了堆栈跟踪所引用的原始代码的确切文件和行。继续阅读以了解有关如何使用<code>decode_stacktrace.sh</code> 的更多信息。</p><h3 id="ramoops-pmsg">ramoops-pmsg</h3><p>ramoops-pmsg 是 ramoops 的用户空间可访问版本。要从 pstore 访问上次重启之前的这些日志，可以运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ adb logcat -b all -L<br></code></pre></td></tr></table></figure><p>关于ramoops内核特性更详细的解释可以在下面找到。</p><h2 id="内核空间调试">内核空间调试</h2><p>内核空间调试帮助我们识别在内核内部的问题。设备制造商除了提供设备的内核驱动以外，还可能在发布内核源码时客制内核的其他部分。因此，当设备制造商将他们的驱动变基到新版本内核上的时候（为了跟上安全补丁），可能会出现回归。</p><h3 id="dmesg">dmesg</h3><p><code>dmesg</code> 是一个显示内核缓冲区消息的命令行工具。它提供了内核级活动的详细视图，使设备维护者能够诊断系统崩溃、驱动问题并监视系统事件。请注意，所有 LineageOS 构建都默认 SELinux Enforcing，这要求你在使用 dmesg 之前 <code>adb root</code> 模式。</p><p>下面是 dmesg 的关于空指针引用的截断输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">adb shell dmesg</span><br>| Unable to handle kernel NULL pointer dereference at virtual address 0000000000000010<br>| Internal error: Oops: 96000006 [#1] SMP<br>| Call trace:<br>| update_insn_emulation_mode+0xc0/0x148<br>| emulation_proc_handler+0x64/0xb8<br>| proc_sys_call_handler+0x9c/0xf8<br>| proc_sys_write+0x18/0x20<br>| __vfs_write+0x20/0x48<br>| vfs_write+0xe4/0x1d0<br>| ksys_write+0x70/0xf8<br>| __arm64_sys_write+0x20/0x28<br>| el0_svc_common.constprop.0+0x7c/0x1c0<br>| el0_svc_handler+0x2c/0xa0<br>| el0_svc+0x8/0x200<br></code></pre></td></tr></table></figure><h3 id="ramoops">ramoops</h3><p>ramoops 是 <a href="https://www.kernel.org/doc/html/next/admin-guide/ramoops.html">Linux 内核的一项功能</a>，可在系统崩溃前写入内存。ramoops 可在设备的内核设备树源码 (DTS) 中配置，方法是为 ramoops-pmsg 保留一个内存缓冲区。它与内核 pstore 驱动程序配合使用，在重新启动前将 ramoops 保存到 <code>/sys/fs/pstore</code> 的持久文件中。</p><p>分配了 pmsg 缓冲区的 ramoops 配置示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">/&#123;<br>    reserved-memory &#123;<br>        ramoops: ramoops@b0000000 &#123;<br>            compatible = <span class="hljs-string">&quot;ramoops&quot;</span>;<br>            reg = &lt;<span class="hljs-number">0</span> <span class="hljs-number">0xb0000000</span> <span class="hljs-number">0</span> <span class="hljs-number">0x00400000</span>&gt;;<br>            record-size = &lt;<span class="hljs-number">0x40000</span>&gt;; <span class="hljs-comment">/*256x1024*/</span><br>            console-size = &lt;<span class="hljs-number">0x40000</span>&gt;;<br>            ftrace-size = &lt;<span class="hljs-number">0x40000</span>&gt;;<br>            pmsg-size = &lt;<span class="hljs-number">0x200000</span>&gt;;<br>            ecc-size = &lt;<span class="hljs-number">0x0</span>&gt;;<br>        &#125;;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在较新的内核上， ramoops 可以通过如下配置选项启用：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_PSTORE</span>=y<br><span class="hljs-attr">CONFIG_PSTORE_CONSOLE</span>=y<br><span class="hljs-attr">CONFIG_PSTORE_RAM</span>=y<br></code></pre></td></tr></table></figure><p>pstore 通常默认压缩，这使得它难以在调试中使用。你可能想通过如下设置来禁用压缩：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"># CONFIG_PSTORE_COMPRESS <span class="hljs-keyword">is</span> not <span class="hljs-keyword">set</span><br></code></pre></td></tr></table></figure><p>尽管 ramoops 和 pstore 都是强大的工具，但使用它们时仍有一些注意事项。由于 pstore 默认将数据写入缓冲区，并且我们通常只在系统即将崩溃时使用它，因此事后检索 pstore 时，我们往往会看到大量损坏。</p><h3 id="addr2line">addr2line</h3><p>dmesg 和 ramoops 经常在堆栈跟踪中产生加密的内存地址，例如<code>ffffff9405cebf10</code>来自：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">CFI failure (<span class="hljs-keyword">target</span>: [\&lt;\ffffff<span class="hljs-number">9405</span>cebf<span class="hljs-number">10</span>\&gt;] __typeid__ZTSFvP<span class="hljs-number">10</span>net_deviceE_global_addr<span class="hljs-number">+0</span><span class="hljs-keyword">x</span><span class="hljs-number">170</span>/<span class="hljs-number">0x17c</span>):<br></code></pre></td></tr></table></figure><p>在这种情况下，我们可以使用 Address To Line (addr2line) 来找到出现问题的文件和行数，使用：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>addr2line -e /path/to/kernel-<span class="hljs-keyword">module</span>.o ffffff9405cebf10<br></code></pre></td></tr></table></figure><h3 id="decode-stacktrace-sh">decode_stacktrace.sh</h3><p><code>decode_stacktrace.sh</code> 是每个 Linux 内核附带脚本，使用<code>addr2line</code>，源码位于 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/scripts/decode_stacktrace.sh">linux/blob/master/scripts/decode_stacktrace.sh</a> 。要使用它，首先你需要在内核配置文件中启用 <code>CONFIG_DEBUG_INFO=y</code> 并构建内核。</p><p>接下来，你需要从 dmesg 中提取要调试的内核恐慌的调用跟踪，并将其保存在文本文件中，例如此处的 dmesg.txt：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">| update_insn_emulation_mode+0xc0/0x148</span><br><span class="hljs-string">| emulation_proc_handler+0x64/0xb8</span><br><span class="hljs-string">| proc_sys_call_handler+0x9c/0xf8</span><br><span class="hljs-string">| proc_sys_write+0x18/0x20</span><br><span class="hljs-string">| __vfs_write+0x20/0x48</span><br><span class="hljs-string">| vfs_write+0xe4/0x1d0</span><br><span class="hljs-string">| ksys_write+0x70/0xf8</span><br><span class="hljs-string">| __arm64_sys_write+0x20/0x28</span><br><span class="hljs-string">| el0_svc_common.constprop.0+0x7c/0x1c0</span><br><span class="hljs-string">| el0_svc_handler+0x2c/0xa0</span><br><span class="hljs-string">| el0_svc+0x8/0x200</span><br></code></pre></td></tr></table></figure><p>最后，将 dmesg.txt 和构建好的内核提供给 <code>decode_stacktrace.sh</code> ：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ./scripts/decode_stacktrace.sh /path/to/vmlinux /path/to/kernel-source-dir &lt; dmesg.txt<br></code></pre></td></tr></table></figure><p>正如你在以下示例（不同的堆栈跟踪）中看到的，堆栈跟踪中每个调用的内存地址已被替换为特定文件和代码行，然后您可以在内核源码中找到它。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">| dump_stack (lib/dump_stack.c:52)</span><br><span class="hljs-string">| warn_slowpath_common (kernel/panic.c:418)</span><br><span class="hljs-string">| warn_slowpath_null (kernel/panic.c:453)</span><br><span class="hljs-string">| _oalloc_pages_slowpath+0x6a/0x7d0</span><br><span class="hljs-string">| ? zone_watermark_ok (mm/page_alloc.c:1728)</span><br><span class="hljs-string">| ? get_page_from_freelist (mm/page_alloc.c:1939)</span><br><span class="hljs-string">| __alloc_pages_nodemask (mm/page_alloc.c:2766)</span><br></code></pre></td></tr></table></figure><h3 id="串口-gdb">串口 / gdb</h3><p>带有 UART 端口的设备（参见带有 3.5 毫米耳机端口的旧款 Nexus/Google Pixel 和带有 USB-C 调试器的新款 Google Pixel）可以使用 UART 线连接来查看内核控制台消息 (kgdb)。使用串口，你甚至可以调试内核启动前发生的问题。</p><p>当你的设备卡在 logo 上时，可以考虑使用串口。</p><h3 id="绝望的调试">绝望的调试</h3><p>如果其他方法都失败了，你可以在要调试的内核部分使用 <code>panic()</code>。<a href="https://github.com/xiaomi-sm8150-devs/android_kernel_xiaomi_sm8150-legacy/commit/9d8822a6967ee623790270539a929942b71f191b">SebaUbuntu 的补丁</a>在此处演示了如何使用 <code>panic()</code> 来捕获早期初始化问题。</p><h2 id="芯片制造商-OEM-特定的调试方法">芯片制造商 / OEM 特定的调试方法</h2><p>这是我们这几年发现的非常有用的调试工具，它们由OEM开发。</p><h3 id="EDL-memorydump-（高通）">EDL memorydump （高通）</h3><p><img src="https://lineageos.org/images/engineering/content_qualcomm_crashdump.png" alt=""></p><p>一些高通设备启用了 CrashDump，允许你使用高通的 firehouse 工具来获取内存转储。由于 firehouse 是闭源的，我们建议使用由 Bjoern Kerler 重写的开源版，可以在 <a href="https://github.com/bkerler/edl">bkerler/edl</a> 找到。你可以使用 <code>edl memorydump</code> 获取内存转储。</p><h3 id="dev-block-by-name-debug-（三星）">/dev/block/by-name/debug （三星）</h3><p><code>/dev/block/by-name/debug</code> 是三星设备上一个特殊的设备块文件，它包含了XBL日志、内核日志以及更多东西。你可以执行 <code>adb pull /dev/block/by-name/debug debug.bin</code> 来转储日志流。</p><p>下面是一个截断的 debug.bin 文件的示例：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">&#123;</span><span class="hljs-number">340532</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-operator">**</span> <span class="hljs-variable">XBL</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">**</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-number">340532</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-built_in">Format</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Log</span> <span class="hljs-variable">Type</span> <span class="hljs-operator">-</span> <span class="hljs-variable">Time</span><span class="hljs-punctuation">(</span><span class="hljs-variable">microsec</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">-</span> <span class="hljs-built_in">Message</span> <span class="hljs-operator">-</span> <span class="hljs-built_in">Optional</span> <span class="hljs-variable">Info</span><br><span class="hljs-built_in">Log</span> <span class="hljs-variable">Type</span><span class="hljs-operator">:</span> <span class="hljs-variable">B</span> <span class="hljs-operator">-</span> <span class="hljs-variable">Since</span> <span class="hljs-variable">Boot</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Power</span> <span class="hljs-built_in">On</span> <span class="hljs-variable">Reset</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span>  <span class="hljs-built_in">D</span> <span class="hljs-operator">-</span> <span class="hljs-variable">Delta</span><span class="hljs-operator">,</span>  <span class="hljs-variable">S</span> <span class="hljs-operator">-</span> <span class="hljs-variable">Statistic</span><br><span class="hljs-variable">S</span> <span class="hljs-operator">-</span> <span class="hljs-type">QC_IMAGE</span><span class="hljs-type">_VERSION</span><span class="hljs-type">_STRING</span><span class="hljs-operator">=</span><span class="hljs-variable">BOOT</span><span class="hljs-operator">.</span><span class="hljs-variable">XF</span><span class="hljs-number">.2</span><span class="hljs-number">.1</span><span class="hljs-operator">-</span><span class="hljs-number">00133</span><span class="hljs-operator">-</span><span class="hljs-variable">SDM710LZB</span><span class="hljs-operator">-</span><span class="hljs-number">3</span><br><span class="hljs-variable">S</span> <span class="hljs-operator">-</span> <span class="hljs-type">IMAGE_VARIANT</span><span class="hljs-type">_STRING</span><span class="hljs-operator">=</span><span class="hljs-variable">SDM670LA</span><br><span class="hljs-variable">S</span> <span class="hljs-operator">-</span> <span class="hljs-type">OEM_IMAGE</span><span class="hljs-type">_VERSION</span><span class="hljs-type">_STRING</span><span class="hljs-operator">=</span><span class="hljs-number">21</span><span class="hljs-variable">DJFC21</span><br><span class="hljs-variable">S</span> <span class="hljs-operator">-</span> <span class="hljs-variable">Boot</span> <span class="hljs-variable">Interface</span><span class="hljs-operator">:</span> <span class="hljs-variable">eMMC</span><br><span class="hljs-variable">S</span> <span class="hljs-operator">-</span> <span class="hljs-variable">Secure</span> <span class="hljs-variable">Boot</span><span class="hljs-operator">:</span> <span class="hljs-built_in">On</span><br><span class="hljs-variable">S</span> <span class="hljs-operator">-</span> <span class="hljs-variable">Boot</span> <span class="hljs-variable">Config</span> <span class="hljs-operator">@</span> <span class="hljs-number">0</span><span class="hljs-variable">x00786070</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-variable">x000000c9</span><br><span class="hljs-variable">S</span> <span class="hljs-operator">-</span> <span class="hljs-variable">JTAG</span> <span class="hljs-variable">ID</span> <span class="hljs-operator">@</span> <span class="hljs-number">0</span><span class="hljs-variable">x00786130</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-variable">x100910e1</span><br><span class="hljs-variable">S</span> <span class="hljs-operator">-</span> <span class="hljs-variable">OEM</span> <span class="hljs-variable">ID</span> <span class="hljs-operator">@</span> <span class="hljs-number">0</span><span class="hljs-variable">x00786138</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-variable">x00200000</span><br><span class="hljs-variable">S</span> <span class="hljs-operator">-</span> <span class="hljs-variable">Feature</span> <span class="hljs-variable">Config</span> <span class="hljs-built_in">Row</span> <span class="hljs-number">0</span> <span class="hljs-operator">@</span> <span class="hljs-number">0</span><span class="hljs-variable">x007841a0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-variable">x08d020000b588420</span><br><span class="hljs-variable">S</span> <span class="hljs-operator">-</span> <span class="hljs-variable">Feature</span> <span class="hljs-variable">Config</span> <span class="hljs-built_in">Row</span> <span class="hljs-number">1</span> <span class="hljs-operator">@</span> <span class="hljs-number">0</span><span class="hljs-variable">x007841a8</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-variable">xe0140000000311a0</span><br><span class="hljs-variable">S</span> <span class="hljs-operator">-</span> <span class="hljs-variable">Core</span> <span class="hljs-number">0</span> <span class="hljs-variable">Frequency</span><span class="hljs-operator">,</span> <span class="hljs-number">1516</span> <span class="hljs-variable">MHz</span><br><span class="hljs-variable">S</span> <span class="hljs-operator">-</span> <span class="hljs-variable">PBL</span> <span class="hljs-variable">Patch</span> <span class="hljs-variable">Ver</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><br><span class="hljs-variable">S</span> <span class="hljs-operator">-</span> <span class="hljs-variable">PBL</span> <span class="hljs-variable">freq</span><span class="hljs-operator">:</span> <span class="hljs-number">600</span> <span class="hljs-variable">MHZ</span><br><span class="hljs-variable">S</span> <span class="hljs-operator">-</span> <span class="hljs-built_in">I</span><span class="hljs-operator">-</span><span class="hljs-variable">cache</span><span class="hljs-operator">:</span> <span class="hljs-built_in">On</span><br><span class="hljs-variable">S</span> <span class="hljs-operator">-</span> <span class="hljs-built_in">D</span><span class="hljs-operator">-</span><span class="hljs-variable">cache</span><span class="hljs-operator">:</span> <span class="hljs-built_in">On</span><br></code></pre></td></tr></table></figure><p>我们之前讲解<a href="https://lineageos.org/engineering/Qualcomm-Firmware">高通的信任链</a>的博客有关于 eXtensible Bootloader (XBL) 的更多细节。</p><h2 id="常见错误-以及如何解决">常见错误 (以及如何解决)</h2><p>现在我们对 Android 开发过程中使用的某些调试工具有了基本的了解，现在让我们学习如何识别和修复调试过程中遇到的常见错误。</p><h3 id="dlopen-failed">dlopen failed</h3><p>许多设备都具有预构建库，这些库是使用旧版本的库编译的，这些旧版本的库缺失某些符号。可能发生如下所示的错误：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">* java.lang.UnsatisfiedLinkError: dlopen failed: cannot locate symbol <span class="hljs-string">&quot;_ZN7android21SurfaceComposerClient11Transaction5applyEb&quot;</span> referenced <span class="hljs-keyword">by</span> <span class="hljs-string">&quot;/product/lib64/libsecureuisvc_jni.so&quot;</span><span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p>为了解决此错误，我们需要插入我们俗称“垫片”的库。通过拦截对缺失函数的调用并提供替代的实现，我们可以从本质上模拟正在使用的预构建库构建的原始库的行为。</p><p>另外，一些现代设备会选择将更新库的旧 VNDK 版本复制到  <code>$libname-v$vndkVersion.so</code> ，然后对有问题的库打补丁，以加载该版本的库。</p><p>你可以<a href="https://github.com/LineageOS/android_hardware_lineage_compat">在此处</a>查看我们通用的预先存在的垫片，这些垫片在 LineageOS 20 之前由各个设备维护者管理。对于上述示例，你可以参考<a href="https://review.lineageos.org/c/LineageOS/android_device_google_bonito/+/343466">此补丁</a>，了解如何将垫片包用于需要它们的预构建库。</p><h3 id="Hidden-dlopen-failed">Hidden dlopen failed</h3><p>由于 dlopen 错误仅在运行时发生，因此某些故障不会立即显示，甚至不会记录在日志中。因此，我们想出了一个库钩子 ，<code> dlopen.so</code> ，你可以将其放置在 LD_PRELOAD 中，显示所有链接器操作，帮助我们查看哪些库当前缺少符号甚至缺少依赖项。</p><p>这是某个设备使用<a href="https://review.lineageos.org/c/LineageOS/android_hardware_lineage_compat/+/346648">此库</a>的日志：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs livescript">instantnoodlep / <span class="hljs-comment"># LD_PRELOAD=dlopen.so /vendor/bin/hw/android.hardware.gnss\@2.1-service-qti</span><br>dlopen<span class="hljs-function"><span class="hljs-params">(libnetd_client.so)</span> -&gt;</span> <span class="hljs-number">0x0</span>, errno: dlopen failed: library <span class="hljs-string">&quot;libnetd_client.so&quot;</span> <span class="hljs-keyword">not</span> found<br>dlopen<span class="hljs-function"><span class="hljs-params">(libgnss.so)</span> -&gt;</span> <span class="hljs-number">0xdc9f08e905187e63</span>, errno: (<span class="hljs-literal">null</span>)<br>dlopen<span class="hljs-function"><span class="hljs-params">(liblbs_core.so)</span> -&gt;</span> <span class="hljs-number">0x618992fa4f6a1e6d</span>, errno: (<span class="hljs-literal">null</span>)<br>dlopen<span class="hljs-function"><span class="hljs-params">(liblocdiagiface.so)</span> -&gt;</span> <span class="hljs-number">0x0</span>, errno: dlopen failed: library <span class="hljs-string">&quot;liblocdiagiface.so&quot;</span> <span class="hljs-keyword">not</span> found<br>dlopen<span class="hljs-function"><span class="hljs-params">(libloc_net_iface.so)</span> -&gt;</span> <span class="hljs-number">0x0</span>, errno: dlopen failed: library <span class="hljs-string">&quot;libloc_net_iface.so&quot;</span> <span class="hljs-keyword">not</span> found<br>dlopen<span class="hljs-function"><span class="hljs-params">(vendor.qti.gnss@<span class="hljs-number">4.0</span>-service.so)</span> -&gt;</span> <span class="hljs-number">0xe8b09305c7a1c55f</span>, errno: (<span class="hljs-literal">null</span>)<br>dlopen<span class="hljs-function"><span class="hljs-params">(libdataitems.so)</span> -&gt;</span> <span class="hljs-number">0xc4ba0f7c15946aef</span>, errno: (<span class="hljs-literal">null</span>)<br>dlopen<span class="hljs-function"><span class="hljs-params">(android.hardware.gnss@<span class="hljs-number">2.1</span>-impl-qti.so)</span> -&gt;</span> <span class="hljs-number">0xd950565f49bbcc01</span>, errno: (<span class="hljs-literal">null</span>)<br>dlopen<span class="hljs-function"><span class="hljs-params">(libgnss.so)</span> -&gt;</span> <span class="hljs-number">0xdc9f08e905187e63</span>, errno: (<span class="hljs-literal">null</span>)<br>dlopen<span class="hljs-function"><span class="hljs-params">(libxtadapter.so)</span> -&gt;</span> <span class="hljs-number">0x39eb3dbc835592b5</span>, errno: (<span class="hljs-literal">null</span>)<br>dlopen<span class="hljs-function"><span class="hljs-params">(libcdfw.so)</span> -&gt;</span> <span class="hljs-number">0x59b12f3c0b5e3e1b</span>, errno: (<span class="hljs-literal">null</span>)<br>dlopen<span class="hljs-function"><span class="hljs-params">(libloc_socket.so)</span> -&gt;</span> <span class="hljs-number">0x2229c8abec54dac9</span>, errno: (<span class="hljs-literal">null</span>)<br></code></pre></td></tr></table></figure><h2 id="One-more-thing">One more thing</h2><p>当调试非私有系统应用的时候，比如 Aperture ，你可以使用 <a href="https://developer.android.com/studio">Android Studio</a> 来更轻松简单地进行调试！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>UART Ports For Google Pixel Phones</title>
    <link href="/2024/08/12/UART-Ports-For-Google-Pixel-Phones/"/>
    <url>/2024/08/12/UART-Ports-For-Google-Pixel-Phones/</url>
    
    <content type="html"><![CDATA[<h1>Pixel 手机的 UART 针脚定义</h1><h2 id="启用-UART-终端">启用 UART 终端</h2><p>在 Ｐixel 上启用 UART 需要已解锁的 bootloader<br>解锁后，进入 bootloader，执行<br><code>fastboot oem uart enable</code><br>执行结果返回“OKAY”即开启 UART 终端<br>UART参数为115200n8，没有硬件串口流控制</p><h2 id="对于存在3-5mm耳机口的型号">对于存在3.5mm耳机口的型号</h2><p>UART从3.5mm接口引出，TX电压应设为1.8V（3.3V应该不会有问题），Sleeve施加3.3V不会有问题<br>若UART适配器只支持3.3V，可在TXD和GND加2k和2.4k电阻分压<br>TRRS定义为：将TRRS接头的尖头朝左放置，从左到右按塑料环为分割，分别是Tip、Ring1、Ring2、Sleeve<br>UART接线定义如下：</p><table><thead><tr><th>UART</th><th style="text-align:left">TRRS</th></tr></thead><tbody><tr><td>3.3V</td><td style="text-align:left">Sleeve</td></tr><tr><td>GND</td><td style="text-align:left">Ring2</td></tr><tr><td>TXD</td><td style="text-align:left">Ring1</td></tr><tr><td>RXD</td><td style="text-align:left">Tip</td></tr></tbody></table><h2 id="对于仅有-USB-C-而没有3-5mm的型号">对于仅有 USB-C 而没有3.5mm的型号</h2><p>UART从USB-C中引出<br>USB-C线材必须引出USB2.0, SBU1/SBU2, CC1(CC) 和 CC2(VCONN)<br>到这里，所有的USB-A to USB-C的线材都可以毙掉了<br>UART接线定义如下：</p><table><thead><tr><th>UART</th><th style="text-align:left">Type-C</th></tr></thead><tbody><tr><td>GND</td><td style="text-align:left">GND</td></tr><tr><td>RXD(1.8V)</td><td style="text-align:left">SBU1</td></tr><tr><td>TXD</td><td style="text-align:left">SBU2</td></tr><tr><td>5V</td><td style="text-align:left">VCC</td></tr></tbody></table><p>值得注意的是这里的SBU1和SBU2是区分RX和TX的，所以USB-C不能反插<br>Pixel 5a 5G和Pixel 2 有不同的USB-C翻转方向<br>您也可以直接从主板上引出UART，这样就不影响使用ADB了<br>当然，如果你觉得这样太麻烦，也可以参考<a href="https://github.com/google/usb-cereal">Google开源的工程线</a>或者<a href="https://github.com/Peter-Easton/android-debug-cable-howto">第三方的线</a><br>注意，以上内容可能不适用于Pixel5(redfin)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++多线程获取返回值的方法</title>
    <link href="/2021/08/27/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%8E%B7%E5%8F%96%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2021/08/27/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%8E%B7%E5%8F%96%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在许多时候，我们会有这样的需求——即我们想要得到线程返回的值。但是在C++11 多线程中我们注意到，std::thread对象会忽略顶层函数的返回值。</p><p>那问题来了，我们要怎么获得线程的返回值呢？</p><p>我们通过一个例子来说明如何实现这个需求。用多个线程计算（a+b）/ (x+y) 的值</p><p>有两种方法，分别是</p><h1><strong>1. 传统的方法：在线程间共享指针</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>#<span class="hljs-keyword">include</span>#<span class="hljs-keyword">include</span>#includeusing namespace std;</span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y,<span class="hljs-type">int</span>* ans)</span> </span>&#123;<br>  *ans= x + y;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//计算（a+b）/(x+y)</span><br>  <span class="hljs-comment">//用三个线程，一个线程计算a+b，另一个线程计算x+y</span><br>  <span class="hljs-type">int</span> a, b, x, y;<br>  a = <span class="hljs-number">10</span>, b = <span class="hljs-number">8</span>, x = <span class="hljs-number">2</span>, y = <span class="hljs-number">4</span>;<br> <br>  <span class="hljs-type">int</span>* sum1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-type">int</span>* sum2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">(func2, a, b, sum1)</span></span>;<br>  t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>  <span class="hljs-function">thread <span class="hljs-title">t2</span><span class="hljs-params">(func2, x, y, sum2)</span></span>;<br>  t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>   <br>  cout &lt;&lt; (*sum1) / (*sum2) &lt;&lt; endl;<br> <br>  <span class="hljs-keyword">delete</span> sum1;<br>  <span class="hljs-keyword">delete</span> sum2;<br>   <br>  <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><strong>2. C++11的方法：使用std::future和std::promise</strong></h1><p>std::future和std::promise是封装好的两个类模板，这两个类需要配合使用，他们的头文件是#include</p><p>std::future，它表示存储着一个未来会被初始化的变量。这个变量可以通过std::future提供的成员函数std::future::get()来得到。如果在这个变量被赋值之前就有别的线程试图通过std::future::get()获取这个变量，那么这个线程将会被阻塞到这个变量可以获取为止。</p><p>std::promise同样也是一个类模板，这个对象承诺在未来一定会初始化一个变量(这个变量也就是std::future中的变量)。</p><p>每一个std::promise对象都有一个与之关联的std::future对象。当std::promise设置值的时候，这个值就会赋给std::future中的对象了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>#<span class="hljs-keyword">include</span>#<span class="hljs-keyword">include</span>#<span class="hljs-keyword">include</span>#<span class="hljs-keyword">include</span><span class="hljs-comment">//std::future std::promise</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-comment">//std::ref模板传参的时候使用</span></span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y,std::promise&amp;promiseObj)</span> </span>&#123;<br>  promiseObj.<span class="hljs-built_in">set_value</span>(x+y);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//计算（a+b）/(x+y)</span><br>  <span class="hljs-comment">//用三个线程，一个线程计算a+b，另一个线程计算x+y</span><br>  <span class="hljs-type">int</span> a, b, x, y;<br>  a = <span class="hljs-number">10</span>, b = <span class="hljs-number">8</span>, x = <span class="hljs-number">2</span>, y = <span class="hljs-number">4</span>;<br> <br>  <span class="hljs-type">int</span> sum1, sum2;<br>  <span class="hljs-comment">//声明一个类</span><br>  std::promisepromiseObj;<br>  <span class="hljs-comment">//将future和promise关联</span><br>  std::futurefutureObj = promiseObj.<span class="hljs-built_in">get_future</span>();<br>  <span class="hljs-comment">//模板传参的时候使用ref，否则传参失败</span><br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func2, a, b, ref(promiseObj))</span></span>;<br>  t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>  <span class="hljs-comment">//获取值</span><br>  sum1 = futureObj.<span class="hljs-built_in">get</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;sum1=&quot;</span> &lt;&lt; sum1 &lt;&lt; std::endl;<br> <br>  <span class="hljs-comment">//不能直接复用上面的future和promise</span><br>  std::promisepromiseObj2;<br>  std::futurefutureObj2 = promiseObj<span class="hljs-number">2.</span><span class="hljs-built_in">get_future</span>();<br> <br>  <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func2, x, y, ref(promiseObj2))</span></span>;<br>  t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>  sum2 = futureObj<span class="hljs-number">2.</span><span class="hljs-built_in">get</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;sum2=&quot;</span> &lt;&lt; sum2 &lt;&lt; std::endl;<br> <br>  std::cout &lt;&lt; <span class="hljs-string">&quot;sum1/sum2=&quot;</span> &lt;&lt; sum1 / sum2 &lt;&lt; std::endl;<br>   <br>  std::<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>-EOF-</p><hr><p>转载自：<a href="http://blog.itpub.net/69955379/viewspace-2702825/">ITPUB</a></p><p>作者：<a href="http://blog.itpub.net/69955379/">大雄45</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ 11 多线程--线程管理</title>
    <link href="/2021/08/27/C-11-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2021/08/27/C-11-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>说到多线程编程，那么就不得不提<em>并行<strong>和</strong>并发**，多线程是实现并发（并行）的一种手段。<strong>并行</strong>是指两个或多个独立的操作**同时进行。注意这里是</em> <em>同时进行</em>，区别于<strong>并发</strong>，在一个时间段内执行多个操作。在单核时代，多个线程是<strong>并发</strong>的，在一个时间段内轮流执行；在多核时代，多个线程可以实现真正的<strong>并行</strong>，在多核上真正独立的并行执行。例如现在常见的<strong>4核4线程</strong>可以并行4个线程；<strong>4核8线程</strong>则使用了超线程技术，把一个物理核模拟为2个逻辑核心，可以并行8个线程。</p><h2 id="并发编程的方法">并发编程的方法</h2><p>通常，要实现并发有两种方法：多进程和多线程。</p><h3 id="多进程并发">多进程并发</h3><p>使用多进程并发是将一个应用程序划分为多个独立的进程（每个进程只有一个线程），这些独立的进程间可以互相通信，共同完成任务。由于操作系统对进程提供了大量的保护机制，以避免一个进程修改了另一个进程的数据，使用多进程比多线程更容易写出<strong>安全</strong>的代码。但这也造就了多进程并发的两个缺点：</p><ul><li>在进程件的通信，无论是使用信号、套接字，还是文件、管道等方式，其使用要么比较复杂，要么就是速度较慢或者两者兼而有之。</li><li>运行多个线程的开销很大，操作系统要分配很多的资源来对这些进程进行管理。</li></ul><p>由于多个进程并发完成同一个任务时，不可避免的是：操作同一个数据和进程间的相互通信，上述的两个缺点也就决定了多进程的并发不是一个好的选择。</p><h3 id="多线程并发">多线程并发</h3><p>多线程并发指的是在同一个进程中执行多个线程。有操作系统相关知识的应该知道，线程是轻量级的进程，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，<strong>同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递</strong>。这样，同一进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。由于缺少操作系统提供的保护机制，在多线程共享数据及通信时，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免<strong>死锁(deadlock)</strong>。</p><h2 id="C-11的多线程初体验">C++ 11的多线程初体验</h2><p>C++11的标准库中提供了多线程库，使用时需要<code>#include &lt;thread&gt;</code>头文件，该头文件主要包含了对线程的管理类<code>std::thread</code>以及其他管理线程相关的类。下面是使用C++多线程库的一个简单示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; i &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br><span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(output, i)</span></span>;<br>t.<span class="hljs-built_in">detach</span>();<br>&#125;<br><br><span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在一个for循环内，创建4个线程分别输出数字0、1、2、3，并且在每个数字的末尾输出换行符。语句<code>thread t(output, i)</code>创建一个线程t，该线程运行<code>output</code>，第二个参数i是传递给<code>output</code>的参数。t在创建完成后自动启动，<code>t.detach</code>表示该线程在后台允许，无需等待该线程完成，继续执行后面的语句。这段代码的功能是很简单的，如果是顺序执行的话，其结果很容易预测得到</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>\n <span class="hljs-number">1</span> \n <span class="hljs-number">2</span> \n <span class="hljs-number">3</span> \n <br></code></pre></td></tr></table></figure><p>但是在并行多线程下，其执行的结果就多种多样了，下图是代码一次运行的结果：<br><img src="https://s3.bmp.ovh/imgs/2021/08/50ec374f6714c26f.png" alt=""></p><p>可以看出，首先输出了01，并没有输出换行符；紧接着却连续输出了2个换行符。不是说好的并行么，同时执行，怎么还有先后的顺序？这就涉及到多线程编程最核心的问题了<strong>资源竞争</strong>。CPU有4核，可以同时执行4个线程这是没有问题了，但是<strong>控制台却只有一个，同时只能有一个线程拥有这个唯一的控制台</strong>，将数字输出。将上面代码创建的四个线程进行编号：t0,t1,t2,t3，分别输出的数字：0,1,2,3。参照上图的执行结果，控制台的拥有权的转移如下：</p><ul><li>t0拥有控制台，输出了数字0，但是其没有来的及输出换行符，控制的拥有权却转移到了t1；（0）</li><li>t1完成自己的输出，t1线程完成 （1\n）</li><li>控制台拥有权转移给t0，输出换行符 （\n）</li><li>t2拥有控制台，完成输出 （2\n）</li><li>t3拥有控制台，完成输出 （3\n)</li></ul><p>由于控制台是系统资源，这里控制台拥有权的管理是操作系统完成的。但是，假如是多个线程共享进程空间的数据，这就需要自己写代码控制，每个线程何时能够拥有共享数据进行操作。<strong>共享数据的管理</strong>以及<strong>线程间的通信</strong>，是多线程编程的两大核心。</p><h2 id="线程管理">线程管理</h2><p>每个应用程序至少有一个进程，而每个进程至少有一个主线程，除了主线程外，在一个进程中还可以创建多个线程。每个线程都需要一个入口函数，入口函数返回退出，该线程也会退出，主线程就是以<code>main</code>函数作为入口函数的线程。在C++ 11的线程库中，将线程的管理在了类<code>std::thread</code>中，使用<code>std::thread</code>可以创建、启动一个线程，并可以将线程挂起、结束等操作。</p><h3 id="启动一个线程">启动一个线程</h3><p>C++ 11的线程库启动一个线程是非常简单的，只需要创建一个<code>std::thread</code>对象，就会启动一个线程，并使用该<code>std::thread</code>对象来管理该线程。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">do_task</span>();<br>std::<span class="hljs-built_in">thread</span>(do_task);<br></code></pre></td></tr></table></figure><p>这里创建<code>std::thread</code>传入的函数，实际上其构造函数需要的是可调用（callable）类型，只要是有函数调用类型的实例都是可以的。所有除了传递函数外，还可以使用：</p><ul><li>lambda表达式</li></ul><p>使用lambda表达式启动线程输出数字</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for (int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 4; i++)</span><br>&#123;<br>thread t([i]&#123;<br>cout &lt;&lt; i &lt;&lt; endl<span class="hljs-comment">;</span><br>&#125;)<span class="hljs-comment">;</span><br>t.detach()<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>重载了()运算符的类的实例</li></ul><p>使用重载了()运算符的类实现多线程数字输出</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; i &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br><span class="hljs-built_in">Task</span> task;<br><span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(task, i)</span></span>;<br>t.<span class="hljs-built_in">detach</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>把函数对象传入<code>std::thread</code>的构造函数时，要注意一个C++的语法解析错误（C++'s most vexing parse）。向<code>std::thread</code>的构造函数中传入的是一个临时变量，而不是命名变量就会出现语法解析错误。如下代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-built_in">Task</span>())</span></span>;<br></code></pre></td></tr></table></figure><p>这里相当于声明了一个函数t，其返回类型为<code>thread</code>，而不是启动了一个新的线程。可以使用新的初始化语法避免这种情况</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">std::thread t&#123;<span class="hljs-built_in">Task</span>()&#125;;<br></code></pre></td></tr></table></figure><p>当线程启动后，<strong>一定要在和线程相关联的<code>thread</code>销毁前，确定以何种方式等待线程执行结束</strong>。C++11有两种方式来等待线程结束</p><ul><li>detach方式，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束。前面代码所使用的就是这种方式。</li><li>join方式，等待启动的线程完成，才会继续往下执行。假如前面的代码使用这种方式，其输出就会0,1,2,3，因为每次都是前一个线程输出完成了才会进行下一个循环，启动下一个新线程。</li></ul><p>无论在何种情形，一定要在<code>thread</code>销毁前，调用<code>t.join</code>或者<code>t.detach</code>，来决定线程以何种方式运行。当使用join方式时，会阻塞当前代码，等待线程完成退出后，才会继续向下执行；而使用detach方式则不会对当前代码造成影响，当前代码继续向下执行，创建的新线程同时并发执行，这时候需要特别注意：<strong>创建的新线程对当前作用域的变量的使用</strong>，创建新线程的作用域结束后，有可能线程仍然在执行，这时局部变量随着作用域的完成都已销毁，如果线程继续使用局部变量的<strong>引用或者指针</strong>，会出现意想不到的错误，并且这种错误很难排查。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> fn = [](<span class="hljs-type">int</span> *a)&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>cout &lt;&lt; *a &lt;&lt; endl; <br>&#125;;<br><br>[]&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">100</span>;<br><br><span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(fn, &amp;a)</span></span>;<br><br>t.<span class="hljs-built_in">detach</span>();<br>&#125;();<br></code></pre></td></tr></table></figure><p>在lambda表达式中，使用fn启动了一个新的线程，在装个新的线程中使用了局部变量a的指针，并且将该线程的运行方式设置为detach。这样，在lamb表达式执行结束后，变量a被销毁，但是在后台运行的线程仍然在使用已销毁变量a的指针，其输出结果如下：<br><img src="https://images2015.cnblogs.com/blog/439761/201612/439761-20161205170939663-1871705465.jpg" alt="img"></p><p>只有第一个输出是正确的值，后面输出的值是a已被销毁后输出的结果。所以在以detach的方式执行线程时，要将线程访问的局部数据复制到线程的空间（使用值传递），一定要确保线程没有使用局部变量的引用或者指针，除非你能肯定该线程会在局部作用域结束前执行结束。当然，使用join方式的话就不会出现这种问题，它会在作用域结束前完成退出。</p><h3 id="异常情况下等待线程完成">异常情况下等待线程完成</h3><p>当决定以detach方式让线程在后台运行时，可以在创建<code>thread</code>的实例后立即调用<code>detach</code>，这样线程就会后<code>thread</code>的实例分离，即使出现了异常<code>thread</code>的实例被销毁，仍然能保证线程在后台运行。但线程以join方式运行时，需要在主线程的合适位置调用<code>join</code>方法，如果调用<code>join</code>前出现了异常，<code>thread</code>被销毁，线程就会被异常所终结。为了避免异常将线程终结，或者由于某些原因，例如线程访问了局部变量，就要保证线程一定要在函数退出前完成，就要保证要在函数退出前调用<code>join</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span>()</span> &#123;<br><span class="hljs-function">thread <span class="hljs-title">t</span>(<span class="hljs-params">[]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">cout &lt;&lt; <span class="hljs-string">&quot;hello C++ 11&quot;</span> &lt;&lt; endl;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span>)</span>;<br><br><span class="hljs-keyword">try</span><br>&#123;<br>do_something_else();<br>&#125;<br><span class="hljs-keyword">catch</span> (...)<br>&#123;<br>t.<span class="hljs-keyword">join</span>();<br><span class="hljs-keyword">throw</span>;<br>&#125;<br>t.<span class="hljs-keyword">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码能够保证在正常或者异常的情况下，都会调用<code>join</code>方法，这样线程一定会在函数<code>func</code>退出前完成。但是使用这种方法，不但代码冗长，而且会出现一些作用域的问题，并不是一个很好的解决方法。</p><p>一种比较好的方法是资源获取即初始化（RAII,Resource Acquisition Is Initialization)，该方法提供一个类，在析构函数中调用<code>join</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">thread_guard</span><br>&#123;<br>thread &amp;t;<br><span class="hljs-keyword">public</span> :<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">thread_guard</span><span class="hljs-params">(thread&amp; <span class="hljs-type">_t</span>)</span> :</span><br><span class="hljs-function">t(_t)&#123;</span>&#125;<br><br>~<span class="hljs-built_in">thread_guard</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (t.<span class="hljs-built_in">joinable</span>())<br>t.<span class="hljs-built_in">join</span>();<br>&#125;<br><br><span class="hljs-built_in">thread_guard</span>(<span class="hljs-type">const</span> thread_guard&amp;) = <span class="hljs-keyword">delete</span>;<br>thread_guard&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> thread_guard&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">([]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">cout &lt;&lt; <span class="hljs-string">&quot;Hello thread&quot;</span> &lt;&lt;endl ;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br><br><span class="hljs-function">thread_guard <span class="hljs-title">g</span><span class="hljs-params">(t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>无论是何种情况，当函数退出时，局部变量<code>g</code>调用其析构函数销毁，从而能够保证<code>join</code>一定会被调用。</p><h3 id="向线程传递参数">向线程传递参数</h3><p>向线程调用的函数传递参数也是很简单的，只需要在构造<code>thread</code>的实例时，依次传入即可。例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n)</span></span>&#123;&#125;<br><br><span class="hljs-type">int</span> buffer[<span class="hljs-number">10</span>];<br><span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(func,buffer,<span class="hljs-number">10</span>)</span></span>;<br>t.<span class="hljs-built_in">join</span>();<br></code></pre></td></tr></table></figure><p>需要注意的是，**默认的会将传递的参数以拷贝的方式复制到线程空间，即使参数的类型是引用。**例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">const</span> string&amp; str)</span></span>;<br><span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(func,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br></code></pre></td></tr></table></figure><p><code>func</code>的第二个参数是<code>string &amp;</code>，而传入的是一个字符串字面量。该字面量以<code>const char*</code>类型传入线程空间后，在<strong>线程的空间内转换为<code>string</code></strong>。</p><p>如果在线程中使用引用来更新对象时，就需要注意了。默认的是将对象拷贝到线程空间，其引用的是拷贝的线程空间的对象，而不是初始希望改变的对象。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">_tagNode</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(_tagNode &amp;node)</span></span><br><span class="hljs-function"></span>&#123;<br>node.a = <span class="hljs-number">10</span>;<br>node.b = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>_tagNode node;<br><br><span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(func, node)</span></span>;<br>t.<span class="hljs-built_in">join</span>();<br><br>cout &lt;&lt; node.a &lt;&lt; endl ;<br>cout &lt;&lt; node.b &lt;&lt; endl ;<br>&#125;<br></code></pre></td></tr></table></figure><p>在线程内，将对象的字段a和b设置为新的值，但是在线程调用结束后，这两个字段的值并不会改变。这样由于引用的实际上是局部变量<code>node</code>的一个拷贝，而不是<code>node</code>本身。在将对象传入线程的时候，调用<code>std::ref</code>，将<code>node</code>的引用传入线程，而不是一个拷贝。<code>thread t(func,std::ref(node));</code></p><p>也可以使用类的成员函数作为线程函数，示例如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">_tagNode</span>&#123;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_some_work</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br>&#125;;<br>_tagNode node;<br><br><span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;_tagNode::do_some_work, &amp;node,<span class="hljs-number">20</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>上面创建的线程会调用<code>node.do_some_work(20)</code>，第三个参数为成员函数的第一个参数，以此类推。</p><h3 id="转移线程的所有权">转移线程的所有权</h3><p><code>thread</code>是可移动的(movable)的，但不可复制(copyable)。可以通过<code>move</code>来改变线程的所有权，灵活的决定线程在什么时候join或者detach。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">(f1)</span></span>;<br><span class="hljs-function">thread <span class="hljs-title">t3</span><span class="hljs-params">(move(t1))</span></span>;<br></code></pre></td></tr></table></figure><p>将线程从t1转移给t3,这时候t1就不再拥有线程的所有权，调用<code>t1.join</code>或<code>t1.detach</code>会出现异常，要使用t3来管理线程。这也就意味着<code>thread</code>可以作为函数的返回类型，或者作为参数传递给函数，能够更为方便的管理线程。</p><p>线程的标识类型为<code>std::thread::id</code>，有两种方式获得到线程的id。</p><ul><li>通过<code>thread</code>的实例调用<code>get_id()</code>直接获取</li><li>在当前线程上调用<code>this_thread::get_id()</code>获取</li></ul><h2 id="总结">总结</h2><p>本文主要介绍了C++11引入的标准多线程库的一些基本操作。有以下内容：</p><ul><li><p>线程的创建</p></li><li><p>线程的执行方式,join或者detach</p></li><li><p>向线程函数传递参数，需要注意的是线程默认是以拷贝的方式传递参数的，当期望传入一个引用时，要使用<code>std::ref</code>进行转换</p></li><li><p>线程是movable的，可以在函数内部或者外部进行传递</p></li><li><p>每个线程都一个标识，可以调用<code>get_id</code>获取。</p><hr></li></ul><p>本文转载自：<a href="https://www.cnblogs.com/wangguchangqing/p/6134635.html">CNBLOG</a></p><p>作者：<a href="https://home.cnblogs.com/u/wangguchangqing/">Brook_icv</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在ManjaroLinux上编译Android源码</title>
    <link href="/2021/08/15/%E5%9C%A8ManjaroLinux%E4%B8%8A%E7%BC%96%E8%AF%91Android%E6%BA%90%E7%A0%81/"/>
    <url>/2021/08/15/%E5%9C%A8ManjaroLinux%E4%B8%8A%E7%BC%96%E8%AF%91Android%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1>在ManjaroLinux上编译Android源码</h1><p>第一次写教程，语文不好大佬手下留情哈哈哈哈</p><p><strong>刷机有风险！请备份好重要数据！自行承担风险！</strong></p><h2 id="系统要求">系统要求</h2><ul><li><p>Manjaro Linux 21.0.7及以上，运行在x86处理器上</p></li><li><p>至少4GB RAM和300GB磁盘空间</p></li><li><p>畅通的互联网连接</p></li><li><p>基本的linux知识</p></li><li><p>脑子和手</p></li></ul><h2 id="配置软件源">配置软件源</h2><h3 id="更换软件源">更换软件源</h3><p>刚安装完的Manjaro需要更换镜像源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman-mirrors -i -c China -m rank<br></code></pre></td></tr></table></figure><p>稍等片刻，选择自己需要的镜像源</p><h4 id="进行全面系统更新">进行全面系统更新</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -Syu<br></code></pre></td></tr></table></figure><h3 id="安装依赖">安装依赖</h3><h4 id="安装yay">安装yay</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S yay<br></code></pre></td></tr></table></figure><h4 id="安装构建依赖">安装构建依赖</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yay -S lineageos-devel</span><br></code></pre></td></tr></table></figure><p>根据需要选择依赖（一路回车和输密码）</p><p>至此，构建依赖安装完成</p><h4 id="建立交换文件">建立交换文件</h4><p>低内存（16G以下）用户请看</p><p>使用dd去创建一个由你自己指定大小的交换文件。例如，创建一个 20 GiB 的交换文件:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo dd <span class="hljs-attribute">if</span>=/dev/zero <span class="hljs-attribute">of</span>=/swapfile <span class="hljs-attribute">bs</span>=1G <span class="hljs-attribute">count</span>=20 <span class="hljs-attribute">status</span>=progress<br></code></pre></td></tr></table></figure><p>为交换文件设置权限（交换文件全局可读是一个巨大的本地漏洞）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> 600 /swapfile<br></code></pre></td></tr></table></figure><p>创建正确大小的文件后，将其格式化用来作为交换文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> mkswap /swapfile<br></code></pre></td></tr></table></figure><p>启用交换文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> swapon /swapfile<br></code></pre></td></tr></table></figure><p>最后，编辑 /etc/fstab，在为交换文件添加一个条目：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">/swapfile <span class="hljs-built_in">none</span> swap defaults <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="下载系统源代码">下载系统源代码</h2><h3 id="配置git">配置git</h3><p>设置git的用户名</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;你的用户名&quot;</span><br></code></pre></td></tr></table></figure><p>设置邮箱</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>由于国内网络环境特殊，可以设置从镜像站下载</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">git config <span class="hljs-params">--global</span> url.https:<span class="hljs-string">//mirrors.bfsu.edu.cn/git/AOSP/.insteadof</span> https:<span class="hljs-string">//android.googlesource.com</span><br>git config <span class="hljs-params">--global</span> url.https:<span class="hljs-string">//github.com.cnpmjs.org/.insteadof</span> https:<span class="hljs-string">//github.com</span><br></code></pre></td></tr></table></figure><h3 id="指定repo更新地址">指定repo更新地址</h3><p>repo的运行过程中会尝试访问官方的git源更新自己，如果想使用bfsu的镜像源进行更新，可以将如下内容复制到你的~/.bashrc里</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">REPO_URL</span>=<span class="hljs-string">&#x27;https://mirrors.bfsu.edu.cn/git/git-repo&#x27;</span><br></code></pre></td></tr></table></figure><p>然后运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><h2 id="建立工作区">建立工作区</h2><p>在符合系统要求的磁盘上建立工作文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> android<br><span class="hljs-built_in">cd</span> android<br></code></pre></td></tr></table></figure><h3 id="初始化仓库">初始化仓库</h3><p>Repo 可以在必要时整合多个 Git 代码库</p><p>Repo是一种对 Git 构成补充的 Google 代码库管理工具</p><p>到Github或其它社区找到您喜欢的ROM中名为platform_manfest或android的git仓库，并找到他们提供的命令。</p><p>例如：</p><p>#LineageOS_18.1</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">repo</span> init -u git://github.com/LineageOS/android.git -b lineage-<span class="hljs-number">18</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>#exTHmUI-11</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">repo init -u https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/exthmui/</span>android.git -b exthm-<span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p>Tip:如果你只想编译，加上–depth=1参数可以节省磁盘空间</p><h2 id="同步仓库">同步仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">repo <span class="hljs-built_in">sync</span><br></code></pre></td></tr></table></figure><p>这将会从网络上下载源码，这个过程可能需要耗费一点时间，请耐心等待</p><p>出现问题可以多同步几遍</p><h2 id="编译">编译</h2><p>这里使用第三方ROM官方支持的手机进行演示，checkin教学将在第二部进行（挖坑）</p><h3 id="环境准备">环境准备</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> build/envsetup.sh<br></code></pre></td></tr></table></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">lunch </span><span class="hljs-template-variable">&#123;ROM名称&#125;</span><span class="language-xml">_</span><span class="hljs-template-variable">&#123;手机开发代号&#125;</span><span class="language-xml">-</span><span class="hljs-template-variable">&#123;构建类型&#125;</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">lunchc aosp_maple-eng</span><br></code></pre></td></tr></table></figure><p>将花括号去掉，在对应的位置上填上您需要的值</p><p>这将会自动下载设备树、内核源码和供应商私有部分</p><h3 id="低内存解决方案">低内存解决方案</h3><p>Android11：在源码根目录执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> build/soong &amp;&amp; git fetch https://github.com/masemoel/build_soong_legion-r 11 &amp;&amp; git cherry-pick b45c5ae22f74f1bdbb9bfbdd06ecf7a25033c78b &amp;&amp; git cherry-pick e020f2130224fbdbec1f83e3adfd06a9764cca87 &amp;&amp; <span class="hljs-built_in">cd</span> ../..<br></code></pre></td></tr></table></figure><p>这将会从远程拉取修补补丁来限定java使用的内存</p><h3 id="正式编译">正式编译</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">mka bacon</span><br></code></pre></td></tr></table></figure><p>#或者</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">mka otapackage</span><br></code></pre></td></tr></table></figure><p>这会花费几个小时甚至数十个小时（取决于系统性能）</p><h3 id="编译完成">编译完成</h3><p>如果没有错误，会出现类似build completed successfully(绿色字体)的输出，这时可以到out/target/product/{手机代号}/目录下找到刷机包</p><p>部分ROM还会在编译完成告知用户刷机包文件位置和文件名</p><h2 id="刷入">刷入</h2><p>现在您得到了刷机包，您可以在自定义Recovery中刷入您的刷机包了！</p><p>如果不开机…….那我也没办法（逃）</p><h2 id="引用">引用</h2><p><a href="https://mirrors.bfsu.edu.cn/help/archlinuxcn/">https://mirrors.bfsu.edu.cn/help/archlinuxcn/</a></p><p><a href="https://mirrors.bfsu.edu.cn/help/git-repo/">https://mirrors.bfsu.edu.cn/help/git-repo/</a></p><p><a href="https://github.com/LineageOS/android">https://github.com/LineageOS/android</a></p><p><a href="https://github.com/exthmui/android/tree/exthm-11">https://github.com/exthmui/android/tree/exthm-11</a></p><p><a href="https://source.android.google.cn/setup/build/building?hl=zh-cn">https://source.android.google.cn/setup/build/building?hl=zh-cn</a></p><p><a href="https://source.android.google.cn/setup/develop?hl=zh-cn">https://source.android.google.cn/setup/develop?hl=zh-cn</a></p><p><a href="https://wiki.archlinux.org/title/Swap_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">https://wiki.archlinux.org/title/Swap_(简体中文)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
