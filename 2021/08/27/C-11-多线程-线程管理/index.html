<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon-96x96.png" color="#222">
  <link rel="manifest" href="/images/site.webmanifest">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shuxiangfan.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="C++多线程探险第二弹">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 11 多线程--线程管理">
<meta property="og:url" content="https://shuxiangfan.github.io/2021/08/27/C-11-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="libfsx&#39;s Blog">
<meta property="og:description" content="C++多线程探险第二弹">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2021/08/50ec374f6714c26f.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/439761/201612/439761-20161205170939663-1871705465.jpg">
<meta property="article:published_time" content="2021-08-27T11:49:34.000Z">
<meta property="article:modified_time" content="2026-02-06T15:01:30.356Z">
<meta property="article:author" content="libfsx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2021/08/50ec374f6714c26f.png">


<link rel="canonical" href="https://shuxiangfan.github.io/2021/08/27/C-11-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://shuxiangfan.github.io/2021/08/27/C-11-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/","path":"2021/08/27/C-11-多线程-线程管理/","title":"C++ 11 多线程--线程管理"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++ 11 多线程--线程管理 | libfsx's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">libfsx's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">并发编程的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91"><span class="nav-number">1.1.</span> <span class="nav-text">多进程并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91"><span class="nav-number">1.2.</span> <span class="nav-text">多线程并发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="nav-number">2.</span> <span class="nav-text">C++ 11的多线程初体验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">线程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">启动一个线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B%E5%AE%8C%E6%88%90"><span class="nav-number">3.2.</span> <span class="nav-text">异常情况下等待线程完成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E7%BA%BF%E7%A8%8B%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="nav-number">3.3.</span> <span class="nav-text">向线程传递参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E7%A7%BB%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-number">3.4.</span> <span class="nav-text">转移线程的所有权</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">libfsx</p>
  <div class="site-description" itemprop="description">诶～泥是怎么找到窝的qwq</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/shuxiangfan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shuxiangfan" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:mail@libfsx.org" title="E-Mail → mailto:mail@libfsx.org" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shuxiangfan.github.io/2021/08/27/C-11-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="libfsx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="libfsx's Blog">
      <meta itemprop="description" content="诶～泥是怎么找到窝的qwq">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++ 11 多线程--线程管理 | libfsx's Blog">
      <meta itemprop="description" content="C++多线程探险第二弹">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ 11 多线程--线程管理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-27 19:49:34" itemprop="dateCreated datePublished" datetime="2021-08-27T19:49:34+08:00">2021-08-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2026-02-06 23:01:30" itemprop="dateModified" datetime="2026-02-06T23:01:30+08:00">2026-02-06</time>
    </span>

  
</div>

            <div class="post-description">C++多线程探险第二弹</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>说到多线程编程，那么就不得不提<em>并行<strong>和</strong>并发**，多线程是实现并发（并行）的一种手段。<strong>并行</strong>是指两个或多个独立的操作**同时进行。注意这里是</em> <em>同时进行</em>，区别于<strong>并发</strong>，在一个时间段内执行多个操作。在单核时代，多个线程是<strong>并发</strong>的，在一个时间段内轮流执行；在多核时代，多个线程可以实现真正的<strong>并行</strong>，在多核上真正独立的并行执行。例如现在常见的<strong>4核4线程</strong>可以并行4个线程；<strong>4核8线程</strong>则使用了超线程技术，把一个物理核模拟为2个逻辑核心，可以并行8个线程。</p>
<h2 id="并发编程的方法">并发编程的方法</h2>
<p>通常，要实现并发有两种方法：多进程和多线程。</p>
<h3 id="多进程并发">多进程并发</h3>
<p>使用多进程并发是将一个应用程序划分为多个独立的进程（每个进程只有一个线程），这些独立的进程间可以互相通信，共同完成任务。由于操作系统对进程提供了大量的保护机制，以避免一个进程修改了另一个进程的数据，使用多进程比多线程更容易写出<strong>安全</strong>的代码。但这也造就了多进程并发的两个缺点：</p>
<ul>
<li>在进程件的通信，无论是使用信号、套接字，还是文件、管道等方式，其使用要么比较复杂，要么就是速度较慢或者两者兼而有之。</li>
<li>运行多个线程的开销很大，操作系统要分配很多的资源来对这些进程进行管理。</li>
</ul>
<p>由于多个进程并发完成同一个任务时，不可避免的是：操作同一个数据和进程间的相互通信，上述的两个缺点也就决定了多进程的并发不是一个好的选择。</p>
<h3 id="多线程并发">多线程并发</h3>
<p>多线程并发指的是在同一个进程中执行多个线程。有操作系统相关知识的应该知道，线程是轻量级的进程，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，<strong>同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递</strong>。这样，同一进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。由于缺少操作系统提供的保护机制，在多线程共享数据及通信时，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免<strong>死锁(deadlock)</strong>。</p>
<h2 id="C-11的多线程初体验">C++ 11的多线程初体验</h2>
<p>C++11的标准库中提供了多线程库，使用时需要<code>#include &lt;thread&gt;</code>头文件，该头文件主要包含了对线程的管理类<code>std::thread</code>以及其他管理线程相关的类。下面是使用C++多线程库的一个简单示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void output(int i)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	for (uint8_t i = 0; i &lt; 4; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		thread t(output, i);</span><br><span class="line">		t.detach();	</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个for循环内，创建4个线程分别输出数字0、1、2、3，并且在每个数字的末尾输出换行符。语句<code>thread t(output, i)</code>创建一个线程t，该线程运行<code>output</code>，第二个参数i是传递给<code>output</code>的参数。t在创建完成后自动启动，<code>t.detach</code>表示该线程在后台允许，无需等待该线程完成，继续执行后面的语句。这段代码的功能是很简单的，如果是顺序执行的话，其结果很容易预测得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 \n 1 \n 2 \n 3 \n </span><br></pre></td></tr></table></figure>
<p>但是在并行多线程下，其执行的结果就多种多样了，下图是代码一次运行的结果：<br>
<img src="https://s3.bmp.ovh/imgs/2021/08/50ec374f6714c26f.png" alt=""></p>
<p>可以看出，首先输出了01，并没有输出换行符；紧接着却连续输出了2个换行符。不是说好的并行么，同时执行，怎么还有先后的顺序？这就涉及到多线程编程最核心的问题了<strong>资源竞争</strong>。CPU有4核，可以同时执行4个线程这是没有问题了，但是<strong>控制台却只有一个，同时只能有一个线程拥有这个唯一的控制台</strong>，将数字输出。将上面代码创建的四个线程进行编号：t0,t1,t2,t3，分别输出的数字：0,1,2,3。参照上图的执行结果，控制台的拥有权的转移如下：</p>
<ul>
<li>t0拥有控制台，输出了数字0，但是其没有来的及输出换行符，控制的拥有权却转移到了t1；（0）</li>
<li>t1完成自己的输出，t1线程完成 （1\n）</li>
<li>控制台拥有权转移给t0，输出换行符 （\n）</li>
<li>t2拥有控制台，完成输出 （2\n）</li>
<li>t3拥有控制台，完成输出 （3\n)</li>
</ul>
<p>由于控制台是系统资源，这里控制台拥有权的管理是操作系统完成的。但是，假如是多个线程共享进程空间的数据，这就需要自己写代码控制，每个线程何时能够拥有共享数据进行操作。<strong>共享数据的管理</strong>以及<strong>线程间的通信</strong>，是多线程编程的两大核心。</p>
<h2 id="线程管理">线程管理</h2>
<p>每个应用程序至少有一个进程，而每个进程至少有一个主线程，除了主线程外，在一个进程中还可以创建多个线程。每个线程都需要一个入口函数，入口函数返回退出，该线程也会退出，主线程就是以<code>main</code>函数作为入口函数的线程。在C++ 11的线程库中，将线程的管理在了类<code>std::thread</code>中，使用<code>std::thread</code>可以创建、启动一个线程，并可以将线程挂起、结束等操作。</p>
<h3 id="启动一个线程">启动一个线程</h3>
<p>C++ 11的线程库启动一个线程是非常简单的，只需要创建一个<code>std::thread</code>对象，就会启动一个线程，并使用该<code>std::thread</code>对象来管理该线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">do_task();</span><br><span class="line">std::thread(do_task);</span><br></pre></td></tr></table></figure>
<p>这里创建<code>std::thread</code>传入的函数，实际上其构造函数需要的是可调用（callable）类型，只要是有函数调用类型的实例都是可以的。所有除了传递函数外，还可以使用：</p>
<ul>
<li>lambda表达式</li>
</ul>
<p>使用lambda表达式启动线程输出数字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 4; i++)</span><br><span class="line">&#123;</span><br><span class="line">	thread t([i]&#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;);</span><br><span class="line">	t.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>重载了()运算符的类的实例</li>
</ul>
<p>使用重载了()运算符的类实现多线程数字输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Task</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void operator()(int i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	for (uint8_t i = 0; i &lt; 4; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Task task;</span><br><span class="line">		thread t(task, i);</span><br><span class="line">		t.detach();	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把函数对象传入<code>std::thread</code>的构造函数时，要注意一个C++的语法解析错误（C++'s most vexing parse）。向<code>std::thread</code>的构造函数中传入的是一个临时变量，而不是命名变量就会出现语法解析错误。如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::thread t(Task());</span><br></pre></td></tr></table></figure>
<p>这里相当于声明了一个函数t，其返回类型为<code>thread</code>，而不是启动了一个新的线程。可以使用新的初始化语法避免这种情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::thread t&#123;Task()&#125;;</span><br></pre></td></tr></table></figure>
<p>当线程启动后，<strong>一定要在和线程相关联的<code>thread</code>销毁前，确定以何种方式等待线程执行结束</strong>。C++11有两种方式来等待线程结束</p>
<ul>
<li>detach方式，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束。前面代码所使用的就是这种方式。</li>
<li>join方式，等待启动的线程完成，才会继续往下执行。假如前面的代码使用这种方式，其输出就会0,1,2,3，因为每次都是前一个线程输出完成了才会进行下一个循环，启动下一个新线程。</li>
</ul>
<p>无论在何种情形，一定要在<code>thread</code>销毁前，调用<code>t.join</code>或者<code>t.detach</code>，来决定线程以何种方式运行。当使用join方式时，会阻塞当前代码，等待线程完成退出后，才会继续向下执行；而使用detach方式则不会对当前代码造成影响，当前代码继续向下执行，创建的新线程同时并发执行，这时候需要特别注意：<strong>创建的新线程对当前作用域的变量的使用</strong>，创建新线程的作用域结束后，有可能线程仍然在执行，这时局部变量随着作用域的完成都已销毁，如果线程继续使用局部变量的<strong>引用或者指针</strong>，会出现意想不到的错误，并且这种错误很难排查。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">auto fn = [](int *a)&#123;</span><br><span class="line">	for (int i = 0; i &lt; 10; i++)</span><br><span class="line">	cout &lt;&lt; *a &lt;&lt; endl; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[]&#123;</span><br><span class="line">	int a = 100;</span><br><span class="line"></span><br><span class="line">	thread t(fn, &amp;a);</span><br><span class="line"></span><br><span class="line">	t.detach();</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>在lambda表达式中，使用fn启动了一个新的线程，在装个新的线程中使用了局部变量a的指针，并且将该线程的运行方式设置为detach。这样，在lamb表达式执行结束后，变量a被销毁，但是在后台运行的线程仍然在使用已销毁变量a的指针，其输出结果如下：<br>
<img src="https://images2015.cnblogs.com/blog/439761/201612/439761-20161205170939663-1871705465.jpg" alt="img"></p>
<p>只有第一个输出是正确的值，后面输出的值是a已被销毁后输出的结果。所以在以detach的方式执行线程时，要将线程访问的局部数据复制到线程的空间（使用值传递），一定要确保线程没有使用局部变量的引用或者指针，除非你能肯定该线程会在局部作用域结束前执行结束。当然，使用join方式的话就不会出现这种问题，它会在作用域结束前完成退出。</p>
<h3 id="异常情况下等待线程完成">异常情况下等待线程完成</h3>
<p>当决定以detach方式让线程在后台运行时，可以在创建<code>thread</code>的实例后立即调用<code>detach</code>，这样线程就会后<code>thread</code>的实例分离，即使出现了异常<code>thread</code>的实例被销毁，仍然能保证线程在后台运行。但线程以join方式运行时，需要在主线程的合适位置调用<code>join</code>方法，如果调用<code>join</code>前出现了异常，<code>thread</code>被销毁，线程就会被异常所终结。为了避免异常将线程终结，或者由于某些原因，例如线程访问了局部变量，就要保证线程一定要在函数退出前完成，就要保证要在函数退出前调用<code>join</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">	thread t([]&#123;</span><br><span class="line">		cout &lt;&lt; &quot;hello C++ 11&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	try</span><br><span class="line">	&#123;</span><br><span class="line">		do_something_else();</span><br><span class="line">	&#125;</span><br><span class="line">	catch (...)</span><br><span class="line">	&#123;</span><br><span class="line">		t.join();</span><br><span class="line">		throw;</span><br><span class="line">	&#125;</span><br><span class="line">	t.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码能够保证在正常或者异常的情况下，都会调用<code>join</code>方法，这样线程一定会在函数<code>func</code>退出前完成。但是使用这种方法，不但代码冗长，而且会出现一些作用域的问题，并不是一个很好的解决方法。</p>
<p>一种比较好的方法是资源获取即初始化（RAII,Resource Acquisition Is Initialization)，该方法提供一个类，在析构函数中调用<code>join</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class thread_guard</span><br><span class="line">&#123;</span><br><span class="line">	thread &amp;t;</span><br><span class="line">public :</span><br><span class="line">	explicit thread_guard(thread&amp; _t) :</span><br><span class="line">		t(_t)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	~thread_guard()</span><br><span class="line">	&#123;</span><br><span class="line">		if (t.joinable())</span><br><span class="line">			t.join();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	thread_guard(const thread_guard&amp;) = delete;</span><br><span class="line">	thread_guard&amp; operator=(const thread_guard&amp;) = delete;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void func()&#123;</span><br><span class="line"></span><br><span class="line">	thread t([]&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Hello thread&quot; &lt;&lt;endl ;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	thread_guard g(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是何种情况，当函数退出时，局部变量<code>g</code>调用其析构函数销毁，从而能够保证<code>join</code>一定会被调用。</p>
<h3 id="向线程传递参数">向线程传递参数</h3>
<p>向线程调用的函数传递参数也是很简单的，只需要在构造<code>thread</code>的实例时，依次传入即可。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func(int *a,int n)&#123;&#125;</span><br><span class="line"></span><br><span class="line">int buffer[10];</span><br><span class="line">thread t(func,buffer,10);</span><br><span class="line">t.join();</span><br></pre></td></tr></table></figure>
<p>需要注意的是，**默认的会将传递的参数以拷贝的方式复制到线程空间，即使参数的类型是引用。**例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void func(int a,const string&amp; str);</span><br><span class="line">thread t(func,3,&quot;hello&quot;);</span><br></pre></td></tr></table></figure>
<p><code>func</code>的第二个参数是<code>string &amp;</code>，而传入的是一个字符串字面量。该字面量以<code>const char*</code>类型传入线程空间后，在<strong>线程的空间内转换为<code>string</code></strong>。</p>
<p>如果在线程中使用引用来更新对象时，就需要注意了。默认的是将对象拷贝到线程空间，其引用的是拷贝的线程空间的对象，而不是初始希望改变的对象。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class _tagNode</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int a;</span><br><span class="line">	int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void func(_tagNode &amp;node)</span><br><span class="line">&#123;</span><br><span class="line">	node.a = 10;</span><br><span class="line">	node.b = 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void f()</span><br><span class="line">&#123;</span><br><span class="line">	_tagNode node;</span><br><span class="line"></span><br><span class="line">	thread t(func, node);</span><br><span class="line">	t.join();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; node.a &lt;&lt; endl ;</span><br><span class="line">	cout &lt;&lt; node.b &lt;&lt; endl ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在线程内，将对象的字段a和b设置为新的值，但是在线程调用结束后，这两个字段的值并不会改变。这样由于引用的实际上是局部变量<code>node</code>的一个拷贝，而不是<code>node</code>本身。在将对象传入线程的时候，调用<code>std::ref</code>，将<code>node</code>的引用传入线程，而不是一个拷贝。<code>thread t(func,std::ref(node));</code></p>
<p>也可以使用类的成员函数作为线程函数，示例如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class _tagNode&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	void do_some_work(int a);</span><br><span class="line">&#125;;</span><br><span class="line">_tagNode node;</span><br><span class="line"></span><br><span class="line">thread t(&amp;_tagNode::do_some_work, &amp;node,20);</span><br></pre></td></tr></table></figure>
<p>上面创建的线程会调用<code>node.do_some_work(20)</code>，第三个参数为成员函数的第一个参数，以此类推。</p>
<h3 id="转移线程的所有权">转移线程的所有权</h3>
<p><code>thread</code>是可移动的(movable)的，但不可复制(copyable)。可以通过<code>move</code>来改变线程的所有权，灵活的决定线程在什么时候join或者detach。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread t1(f1);</span><br><span class="line">thread t3(move(t1));</span><br></pre></td></tr></table></figure>
<p>将线程从t1转移给t3,这时候t1就不再拥有线程的所有权，调用<code>t1.join</code>或<code>t1.detach</code>会出现异常，要使用t3来管理线程。这也就意味着<code>thread</code>可以作为函数的返回类型，或者作为参数传递给函数，能够更为方便的管理线程。</p>
<p>线程的标识类型为<code>std::thread::id</code>，有两种方式获得到线程的id。</p>
<ul>
<li>通过<code>thread</code>的实例调用<code>get_id()</code>直接获取</li>
<li>在当前线程上调用<code>this_thread::get_id()</code>获取</li>
</ul>
<h2 id="总结">总结</h2>
<p>本文主要介绍了C++11引入的标准多线程库的一些基本操作。有以下内容：</p>
<ul>
<li>
<p>线程的创建</p>
</li>
<li>
<p>线程的执行方式,join或者detach</p>
</li>
<li>
<p>向线程函数传递参数，需要注意的是线程默认是以拷贝的方式传递参数的，当期望传入一个引用时，要使用<code>std::ref</code>进行转换</p>
</li>
<li>
<p>线程是movable的，可以在函数内部或者外部进行传递</p>
</li>
<li>
<p>每个线程都一个标识，可以调用<code>get_id</code>获取。</p>
<hr>
</li>
</ul>
<p>本文转载自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangguchangqing/p/6134635.html">CNBLOG</a></p>
<p>作者：<a target="_blank" rel="noopener" href="https://home.cnblogs.com/u/wangguchangqing/">Brook_icv</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>libfsx
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://shuxiangfan.github.io/2021/08/27/C-11-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/" title="C++ 11 多线程--线程管理">https://shuxiangfan.github.io/2021/08/27/C-11-多线程-线程管理/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/08/15/%E5%9C%A8ManjaroLinux%E4%B8%8A%E7%BC%96%E8%AF%91Android%E6%BA%90%E7%A0%81/" rel="prev" title="在ManjaroLinux上编译Android源码">
                  <i class="fa fa-angle-left"></i> 在ManjaroLinux上编译Android源码
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/08/27/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%8E%B7%E5%8F%96%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95/" rel="next" title="C++多线程获取返回值的方法">
                  C++多线程获取返回值的方法 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2021 – 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">除转载外，网站内容均为 CC-BY-SA 4.0 协议</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
